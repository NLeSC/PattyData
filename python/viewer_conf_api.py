#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Mar  4 09:58:04 2015 by generateDS.py version 2.12e.
#
# Command line options:
#   ('-f', '')
#   ('--silence', '')
#   ('-o', 'viewer_conf_api.py')
#
# Command line arguments:
#   viewer_conf.xsd
#
# Command line:
#   /usr/local/bin/generateDS.py -f --silence -o "viewer_conf_api.py" viewer_conf.xsd
#
# Current working directory (os.getcwd()):
#   python
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class objectLibrary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, url=None):
        self.original_tagname_ = None
        self.url = _cast(None, url)
    def factory(*args_, **kwargs_):
        if objectLibrary.subclass:
            return objectLibrary.subclass(*args_, **kwargs_)
        else:
            return objectLibrary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='objectLibrary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectLibrary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='objectLibrary', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectLibrary'):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectLibrary', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='objectLibrary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            showIndent(outfile, level)
            outfile.write('url="%s",\n' % (self.url,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class objectLibrary


class camera(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, h=None, p=None, r=None, y=None, x=None, z=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.h = _cast(None, h)
        self.p = _cast(None, p)
        self.r = _cast(None, r)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.z = _cast(None, z)
    def factory(*args_, **kwargs_):
        if camera.subclass:
            return camera.subclass(*args_, **kwargs_)
        else:
            return camera(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_h(self): return self.h
    def set_h(self, h): self.h = h
    def get_p(self): return self.p
    def set_p(self, p): self.p = p
    def get_r(self): return self.r
    def set_r(self, r): self.r = r
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_z(self): return self.z
    def set_z(self, z): self.z = z
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='camera', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='camera')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='camera', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='camera'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.h is not None and 'h' not in already_processed:
            already_processed.add('h')
            outfile.write(' h=%s' % (self.gds_format_string(quote_attrib(self.h).encode(ExternalEncoding), input_name='h'), ))
        if self.p is not None and 'p' not in already_processed:
            already_processed.add('p')
            outfile.write(' p=%s' % (self.gds_format_string(quote_attrib(self.p).encode(ExternalEncoding), input_name='p'), ))
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            outfile.write(' r=%s' % (self.gds_format_string(quote_attrib(self.r).encode(ExternalEncoding), input_name='r'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (self.gds_format_string(quote_attrib(self.z).encode(ExternalEncoding), input_name='z'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='camera', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='camera'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.h is not None and 'h' not in already_processed:
            already_processed.add('h')
            showIndent(outfile, level)
            outfile.write('h="%s",\n' % (self.h,))
        if self.p is not None and 'p' not in already_processed:
            already_processed.add('p')
            showIndent(outfile, level)
            outfile.write('p="%s",\n' % (self.p,))
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            showIndent(outfile, level)
            outfile.write('r="%s",\n' % (self.r,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y="%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x="%s",\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z="%s",\n' % (self.z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('h', node)
        if value is not None and 'h' not in already_processed:
            already_processed.add('h')
            self.h = value
        value = find_attr_value_('p', node)
        if value is not None and 'p' not in already_processed:
            already_processed.add('p')
            self.p = value
        value = find_attr_value_('r', node)
        if value is not None and 'r' not in already_processed:
            already_processed.add('r')
            self.r = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class camera


class cameras(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, camera=None):
        self.original_tagname_ = None
        if camera is None:
            self.camera = []
        else:
            self.camera = camera
    def factory(*args_, **kwargs_):
        if cameras.subclass:
            return cameras.subclass(*args_, **kwargs_)
        else:
            return cameras(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_camera(self): return self.camera
    def set_camera(self, camera): self.camera = camera
    def add_camera(self, value): self.camera.append(value)
    def insert_camera_at(self, index, value): self.camera.insert(index, value)
    def replace_camera_at(self, index, value): self.camera[index] = value
    def hasContent_(self):
        if (
            self.camera
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cameras', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cameras')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cameras', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cameras'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cameras', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for camera_ in self.camera:
            camera_.export(outfile, level, namespace_, name_='camera', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cameras'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('camera=[\n')
        level += 1
        for camera_ in self.camera:
            showIndent(outfile, level)
            outfile.write('model_.camera(\n')
            camera_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'camera':
            obj_ = camera.factory()
            obj_.build(child_)
            self.camera.append(obj_)
            obj_.original_tagname_ = 'camera'
# end class cameras


class objectRotationSnap(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, degrees=None, pixels=None):
        self.original_tagname_ = None
        self.degrees = _cast(None, degrees)
        self.pixels = _cast(None, pixels)
    def factory(*args_, **kwargs_):
        if objectRotationSnap.subclass:
            return objectRotationSnap.subclass(*args_, **kwargs_)
        else:
            return objectRotationSnap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_degrees(self): return self.degrees
    def set_degrees(self, degrees): self.degrees = degrees
    def get_pixels(self): return self.pixels
    def set_pixels(self, pixels): self.pixels = pixels
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='objectRotationSnap', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='objectRotationSnap')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='objectRotationSnap', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='objectRotationSnap'):
        if self.degrees is not None and 'degrees' not in already_processed:
            already_processed.add('degrees')
            outfile.write(' degrees=%s' % (self.gds_format_string(quote_attrib(self.degrees).encode(ExternalEncoding), input_name='degrees'), ))
        if self.pixels is not None and 'pixels' not in already_processed:
            already_processed.add('pixels')
            outfile.write(' pixels=%s' % (self.gds_format_string(quote_attrib(self.pixels).encode(ExternalEncoding), input_name='pixels'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectRotationSnap', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='objectRotationSnap'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.degrees is not None and 'degrees' not in already_processed:
            already_processed.add('degrees')
            showIndent(outfile, level)
            outfile.write('degrees="%s",\n' % (self.degrees,))
        if self.pixels is not None and 'pixels' not in already_processed:
            already_processed.add('pixels')
            showIndent(outfile, level)
            outfile.write('pixels="%s",\n' % (self.pixels,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('degrees', node)
        if value is not None and 'degrees' not in already_processed:
            already_processed.add('degrees')
            self.degrees = value
        value = find_attr_value_('pixels', node)
        if value is not None and 'pixels' not in already_processed:
            already_processed.add('pixels')
            self.pixels = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class objectRotationSnap


class screen(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, touch=None):
        self.original_tagname_ = None
        self.touch = _cast(None, touch)
    def factory(*args_, **kwargs_):
        if screen.subclass:
            return screen.subclass(*args_, **kwargs_)
        else:
            return screen(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_touch(self): return self.touch
    def set_touch(self, touch): self.touch = touch
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='screen', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='screen')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='screen', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='screen'):
        if self.touch is not None and 'touch' not in already_processed:
            already_processed.add('touch')
            outfile.write(' touch=%s' % (self.gds_format_string(quote_attrib(self.touch).encode(ExternalEncoding), input_name='touch'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='screen', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='screen'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.touch is not None and 'touch' not in already_processed:
            already_processed.add('touch')
            showIndent(outfile, level)
            outfile.write('touch="%s",\n' % (self.touch,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('touch', node)
        if value is not None and 'touch' not in already_processed:
            already_processed.add('touch')
            self.touch = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class screen


class mouse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, steerFriction=None, accel=None, friction=None):
        self.original_tagname_ = None
        self.steerFriction = _cast(None, steerFriction)
        self.accel = _cast(None, accel)
        self.friction = _cast(None, friction)
    def factory(*args_, **kwargs_):
        if mouse.subclass:
            return mouse.subclass(*args_, **kwargs_)
        else:
            return mouse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_steerFriction(self): return self.steerFriction
    def set_steerFriction(self, steerFriction): self.steerFriction = steerFriction
    def get_accel(self): return self.accel
    def set_accel(self, accel): self.accel = accel
    def get_friction(self): return self.friction
    def set_friction(self, friction): self.friction = friction
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mouse', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mouse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mouse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mouse'):
        if self.steerFriction is not None and 'steerFriction' not in already_processed:
            already_processed.add('steerFriction')
            outfile.write(' steerFriction=%s' % (self.gds_format_string(quote_attrib(self.steerFriction).encode(ExternalEncoding), input_name='steerFriction'), ))
        if self.accel is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            outfile.write(' accel=%s' % (self.gds_format_string(quote_attrib(self.accel).encode(ExternalEncoding), input_name='accel'), ))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction=%s' % (self.gds_format_string(quote_attrib(self.friction).encode(ExternalEncoding), input_name='friction'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mouse', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mouse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.steerFriction is not None and 'steerFriction' not in already_processed:
            already_processed.add('steerFriction')
            showIndent(outfile, level)
            outfile.write('steerFriction="%s",\n' % (self.steerFriction,))
        if self.accel is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            showIndent(outfile, level)
            outfile.write('accel="%s",\n' % (self.accel,))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            showIndent(outfile, level)
            outfile.write('friction="%s",\n' % (self.friction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('steerFriction', node)
        if value is not None and 'steerFriction' not in already_processed:
            already_processed.add('steerFriction')
            self.steerFriction = value
        value = find_attr_value_('accel', node)
        if value is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            self.accel = value
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            self.friction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mouse


class softBrake(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, friction=None):
        self.original_tagname_ = None
        self.friction = _cast(None, friction)
    def factory(*args_, **kwargs_):
        if softBrake.subclass:
            return softBrake.subclass(*args_, **kwargs_)
        else:
            return softBrake(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_friction(self): return self.friction
    def set_friction(self, friction): self.friction = friction
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='softBrake', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='softBrake')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='softBrake', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='softBrake'):
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction=%s' % (self.gds_format_string(quote_attrib(self.friction).encode(ExternalEncoding), input_name='friction'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='softBrake', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='softBrake'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            showIndent(outfile, level)
            outfile.write('friction="%s",\n' % (self.friction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            self.friction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class softBrake


class keysLeftRight(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, accel=None, friction=None):
        self.original_tagname_ = None
        self.accel = _cast(None, accel)
        self.friction = _cast(None, friction)
    def factory(*args_, **kwargs_):
        if keysLeftRight.subclass:
            return keysLeftRight.subclass(*args_, **kwargs_)
        else:
            return keysLeftRight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accel(self): return self.accel
    def set_accel(self, accel): self.accel = accel
    def get_friction(self): return self.friction
    def set_friction(self, friction): self.friction = friction
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='keysLeftRight', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='keysLeftRight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='keysLeftRight', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='keysLeftRight'):
        if self.accel is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            outfile.write(' accel=%s' % (self.gds_format_string(quote_attrib(self.accel).encode(ExternalEncoding), input_name='accel'), ))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction=%s' % (self.gds_format_string(quote_attrib(self.friction).encode(ExternalEncoding), input_name='friction'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='keysLeftRight', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='keysLeftRight'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.accel is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            showIndent(outfile, level)
            outfile.write('accel="%s",\n' % (self.accel,))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            showIndent(outfile, level)
            outfile.write('friction="%s",\n' % (self.friction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accel', node)
        if value is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            self.accel = value
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            self.friction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class keysLeftRight


class keysForwardBackward(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, accel=None, friction=None):
        self.original_tagname_ = None
        self.accel = _cast(None, accel)
        self.friction = _cast(None, friction)
    def factory(*args_, **kwargs_):
        if keysForwardBackward.subclass:
            return keysForwardBackward.subclass(*args_, **kwargs_)
        else:
            return keysForwardBackward(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accel(self): return self.accel
    def set_accel(self, accel): self.accel = accel
    def get_friction(self): return self.friction
    def set_friction(self, friction): self.friction = friction
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='keysForwardBackward', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='keysForwardBackward')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='keysForwardBackward', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='keysForwardBackward'):
        if self.accel is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            outfile.write(' accel=%s' % (self.gds_format_string(quote_attrib(self.accel).encode(ExternalEncoding), input_name='accel'), ))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction=%s' % (self.gds_format_string(quote_attrib(self.friction).encode(ExternalEncoding), input_name='friction'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='keysForwardBackward', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='keysForwardBackward'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.accel is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            showIndent(outfile, level)
            outfile.write('accel="%s",\n' % (self.accel,))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            showIndent(outfile, level)
            outfile.write('friction="%s",\n' % (self.friction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accel', node)
        if value is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            self.accel = value
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            self.friction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class keysForwardBackward


class keysVerticalUpDown(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, accel=None, friction=None):
        self.original_tagname_ = None
        self.accel = _cast(None, accel)
        self.friction = _cast(None, friction)
    def factory(*args_, **kwargs_):
        if keysVerticalUpDown.subclass:
            return keysVerticalUpDown.subclass(*args_, **kwargs_)
        else:
            return keysVerticalUpDown(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accel(self): return self.accel
    def set_accel(self, accel): self.accel = accel
    def get_friction(self): return self.friction
    def set_friction(self, friction): self.friction = friction
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='keysVerticalUpDown', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='keysVerticalUpDown')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='keysVerticalUpDown', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='keysVerticalUpDown'):
        if self.accel is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            outfile.write(' accel=%s' % (self.gds_format_string(quote_attrib(self.accel).encode(ExternalEncoding), input_name='accel'), ))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            outfile.write(' friction=%s' % (self.gds_format_string(quote_attrib(self.friction).encode(ExternalEncoding), input_name='friction'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='keysVerticalUpDown', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='keysVerticalUpDown'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.accel is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            showIndent(outfile, level)
            outfile.write('accel="%s",\n' % (self.accel,))
        if self.friction is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            showIndent(outfile, level)
            outfile.write('friction="%s",\n' % (self.friction,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accel', node)
        if value is not None and 'accel' not in already_processed:
            already_processed.add('accel')
            self.accel = value
        value = find_attr_value_('friction', node)
        if value is not None and 'friction' not in already_processed:
            already_processed.add('friction')
            self.friction = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class keysVerticalUpDown


class flySmoothlyToCameras(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, on=None):
        self.original_tagname_ = None
        self.on = _cast(None, on)
    def factory(*args_, **kwargs_):
        if flySmoothlyToCameras.subclass:
            return flySmoothlyToCameras.subclass(*args_, **kwargs_)
        else:
            return flySmoothlyToCameras(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_on(self): return self.on
    def set_on(self, on): self.on = on
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='flySmoothlyToCameras', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='flySmoothlyToCameras')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='flySmoothlyToCameras', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='flySmoothlyToCameras'):
        if self.on is not None and 'on' not in already_processed:
            already_processed.add('on')
            outfile.write(' on=%s' % (self.gds_format_string(quote_attrib(self.on).encode(ExternalEncoding), input_name='on'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='flySmoothlyToCameras', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='flySmoothlyToCameras'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.on is not None and 'on' not in already_processed:
            already_processed.add('on')
            showIndent(outfile, level)
            outfile.write('on="%s",\n' % (self.on,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('on', node)
        if value is not None and 'on' not in already_processed:
            already_processed.add('on')
            self.on = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class flySmoothlyToCameras


class walkMode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, height=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.height = _cast(None, height)
    def factory(*args_, **kwargs_):
        if walkMode.subclass:
            return walkMode.subclass(*args_, **kwargs_)
        else:
            return walkMode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='walkMode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='walkMode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='walkMode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='walkMode'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height=%s' % (self.gds_format_string(quote_attrib(self.height).encode(ExternalEncoding), input_name='height'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='walkMode', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='walkMode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            showIndent(outfile, level)
            outfile.write('height="%s",\n' % (self.height,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            self.height = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class walkMode


class cameraParameters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, screen=None, mouse=None, softBrake=None, keysLeftRight=None, keysForwardBackward=None, keysVerticalUpDown=None, flySmoothlyToCameras=None, walkMode=None):
        self.original_tagname_ = None
        self.screen = screen
        self.mouse = mouse
        self.softBrake = softBrake
        self.keysLeftRight = keysLeftRight
        self.keysForwardBackward = keysForwardBackward
        self.keysVerticalUpDown = keysVerticalUpDown
        self.flySmoothlyToCameras = flySmoothlyToCameras
        self.walkMode = walkMode
    def factory(*args_, **kwargs_):
        if cameraParameters.subclass:
            return cameraParameters.subclass(*args_, **kwargs_)
        else:
            return cameraParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_screen(self): return self.screen
    def set_screen(self, screen): self.screen = screen
    def get_mouse(self): return self.mouse
    def set_mouse(self, mouse): self.mouse = mouse
    def get_softBrake(self): return self.softBrake
    def set_softBrake(self, softBrake): self.softBrake = softBrake
    def get_keysLeftRight(self): return self.keysLeftRight
    def set_keysLeftRight(self, keysLeftRight): self.keysLeftRight = keysLeftRight
    def get_keysForwardBackward(self): return self.keysForwardBackward
    def set_keysForwardBackward(self, keysForwardBackward): self.keysForwardBackward = keysForwardBackward
    def get_keysVerticalUpDown(self): return self.keysVerticalUpDown
    def set_keysVerticalUpDown(self, keysVerticalUpDown): self.keysVerticalUpDown = keysVerticalUpDown
    def get_flySmoothlyToCameras(self): return self.flySmoothlyToCameras
    def set_flySmoothlyToCameras(self, flySmoothlyToCameras): self.flySmoothlyToCameras = flySmoothlyToCameras
    def get_walkMode(self): return self.walkMode
    def set_walkMode(self, walkMode): self.walkMode = walkMode
    def hasContent_(self):
        if (
            self.screen is not None or
            self.mouse is not None or
            self.softBrake is not None or
            self.keysLeftRight is not None or
            self.keysForwardBackward is not None or
            self.keysVerticalUpDown is not None or
            self.flySmoothlyToCameras is not None or
            self.walkMode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cameraParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cameraParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cameraParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cameraParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cameraParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.screen is not None:
            self.screen.export(outfile, level, namespace_, name_='screen', pretty_print=pretty_print)
        if self.mouse is not None:
            self.mouse.export(outfile, level, namespace_, name_='mouse', pretty_print=pretty_print)
        if self.softBrake is not None:
            self.softBrake.export(outfile, level, namespace_, name_='softBrake', pretty_print=pretty_print)
        if self.keysLeftRight is not None:
            self.keysLeftRight.export(outfile, level, namespace_, name_='keysLeftRight', pretty_print=pretty_print)
        if self.keysForwardBackward is not None:
            self.keysForwardBackward.export(outfile, level, namespace_, name_='keysForwardBackward', pretty_print=pretty_print)
        if self.keysVerticalUpDown is not None:
            self.keysVerticalUpDown.export(outfile, level, namespace_, name_='keysVerticalUpDown', pretty_print=pretty_print)
        if self.flySmoothlyToCameras is not None:
            self.flySmoothlyToCameras.export(outfile, level, namespace_, name_='flySmoothlyToCameras', pretty_print=pretty_print)
        if self.walkMode is not None:
            self.walkMode.export(outfile, level, namespace_, name_='walkMode', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cameraParameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.screen is not None:
            showIndent(outfile, level)
            outfile.write('screen=model_.screen(\n')
            self.screen.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mouse is not None:
            showIndent(outfile, level)
            outfile.write('mouse=model_.mouse(\n')
            self.mouse.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.softBrake is not None:
            showIndent(outfile, level)
            outfile.write('softBrake=model_.softBrake(\n')
            self.softBrake.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keysLeftRight is not None:
            showIndent(outfile, level)
            outfile.write('keysLeftRight=model_.keysLeftRight(\n')
            self.keysLeftRight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keysForwardBackward is not None:
            showIndent(outfile, level)
            outfile.write('keysForwardBackward=model_.keysForwardBackward(\n')
            self.keysForwardBackward.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.keysVerticalUpDown is not None:
            showIndent(outfile, level)
            outfile.write('keysVerticalUpDown=model_.keysVerticalUpDown(\n')
            self.keysVerticalUpDown.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flySmoothlyToCameras is not None:
            showIndent(outfile, level)
            outfile.write('flySmoothlyToCameras=model_.flySmoothlyToCameras(\n')
            self.flySmoothlyToCameras.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.walkMode is not None:
            showIndent(outfile, level)
            outfile.write('walkMode=model_.walkMode(\n')
            self.walkMode.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'screen':
            obj_ = screen.factory()
            obj_.build(child_)
            self.screen = obj_
            obj_.original_tagname_ = 'screen'
        elif nodeName_ == 'mouse':
            obj_ = mouse.factory()
            obj_.build(child_)
            self.mouse = obj_
            obj_.original_tagname_ = 'mouse'
        elif nodeName_ == 'softBrake':
            obj_ = softBrake.factory()
            obj_.build(child_)
            self.softBrake = obj_
            obj_.original_tagname_ = 'softBrake'
        elif nodeName_ == 'keysLeftRight':
            obj_ = keysLeftRight.factory()
            obj_.build(child_)
            self.keysLeftRight = obj_
            obj_.original_tagname_ = 'keysLeftRight'
        elif nodeName_ == 'keysForwardBackward':
            obj_ = keysForwardBackward.factory()
            obj_.build(child_)
            self.keysForwardBackward = obj_
            obj_.original_tagname_ = 'keysForwardBackward'
        elif nodeName_ == 'keysVerticalUpDown':
            obj_ = keysVerticalUpDown.factory()
            obj_.build(child_)
            self.keysVerticalUpDown = obj_
            obj_.original_tagname_ = 'keysVerticalUpDown'
        elif nodeName_ == 'flySmoothlyToCameras':
            obj_ = flySmoothlyToCameras.factory()
            obj_.build(child_)
            self.flySmoothlyToCameras = obj_
            obj_.original_tagname_ = 'flySmoothlyToCameras'
        elif nodeName_ == 'walkMode':
            obj_ = walkMode.factory()
            obj_.build(child_)
            self.walkMode = obj_
            obj_.original_tagname_ = 'walkMode'
# end class cameraParameters


class slaveViewClearPitch(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, on=None):
        self.original_tagname_ = None
        self.on = _cast(None, on)
    def factory(*args_, **kwargs_):
        if slaveViewClearPitch.subclass:
            return slaveViewClearPitch.subclass(*args_, **kwargs_)
        else:
            return slaveViewClearPitch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_on(self): return self.on
    def set_on(self, on): self.on = on
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='slaveViewClearPitch', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='slaveViewClearPitch')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='slaveViewClearPitch', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='slaveViewClearPitch'):
        if self.on is not None and 'on' not in already_processed:
            already_processed.add('on')
            outfile.write(' on=%s' % (self.gds_format_string(quote_attrib(self.on).encode(ExternalEncoding), input_name='on'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='slaveViewClearPitch', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='slaveViewClearPitch'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.on is not None and 'on' not in already_processed:
            already_processed.add('on')
            showIndent(outfile, level)
            outfile.write('on="%s",\n' % (self.on,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('on', node)
        if value is not None and 'on' not in already_processed:
            already_processed.add('on')
            self.on = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class slaveViewClearPitch


class clip(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, near_2exp=None, far_2exp=None):
        self.original_tagname_ = None
        self.near_2exp = _cast(None, near_2exp)
        self.far_2exp = _cast(None, far_2exp)
    def factory(*args_, **kwargs_):
        if clip.subclass:
            return clip.subclass(*args_, **kwargs_)
        else:
            return clip(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_near_2exp(self): return self.near_2exp
    def set_near_2exp(self, near_2exp): self.near_2exp = near_2exp
    def get_far_2exp(self): return self.far_2exp
    def set_far_2exp(self, far_2exp): self.far_2exp = far_2exp
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='clip', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clip')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='clip', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='clip'):
        if self.near_2exp is not None and 'near_2exp' not in already_processed:
            already_processed.add('near_2exp')
            outfile.write(' near_2exp=%s' % (self.gds_format_string(quote_attrib(self.near_2exp).encode(ExternalEncoding), input_name='near_2exp'), ))
        if self.far_2exp is not None and 'far_2exp' not in already_processed:
            already_processed.add('far_2exp')
            outfile.write(' far_2exp=%s' % (self.gds_format_string(quote_attrib(self.far_2exp).encode(ExternalEncoding), input_name='far_2exp'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='clip', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='clip'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.near_2exp is not None and 'near_2exp' not in already_processed:
            already_processed.add('near_2exp')
            showIndent(outfile, level)
            outfile.write('near_2exp="%s",\n' % (self.near_2exp,))
        if self.far_2exp is not None and 'far_2exp' not in already_processed:
            already_processed.add('far_2exp')
            showIndent(outfile, level)
            outfile.write('far_2exp="%s",\n' % (self.far_2exp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('near_2exp', node)
        if value is not None and 'near_2exp' not in already_processed:
            already_processed.add('near_2exp')
            self.near_2exp = value
        value = find_attr_value_('far_2exp', node)
        if value is not None and 'far_2exp' not in already_processed:
            already_processed.add('far_2exp')
            self.far_2exp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class clip


class simulation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, roads=None, personDensity=None, maxCars=None, rooms=None):
        self.original_tagname_ = None
        self.roads = _cast(None, roads)
        self.personDensity = _cast(None, personDensity)
        self.maxCars = _cast(None, maxCars)
        self.rooms = _cast(None, rooms)
    def factory(*args_, **kwargs_):
        if simulation.subclass:
            return simulation.subclass(*args_, **kwargs_)
        else:
            return simulation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_roads(self): return self.roads
    def set_roads(self, roads): self.roads = roads
    def get_personDensity(self): return self.personDensity
    def set_personDensity(self, personDensity): self.personDensity = personDensity
    def get_maxCars(self): return self.maxCars
    def set_maxCars(self, maxCars): self.maxCars = maxCars
    def get_rooms(self): return self.rooms
    def set_rooms(self, rooms): self.rooms = rooms
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='simulation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='simulation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='simulation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='simulation'):
        if self.roads is not None and 'roads' not in already_processed:
            already_processed.add('roads')
            outfile.write(' roads=%s' % (self.gds_format_string(quote_attrib(self.roads).encode(ExternalEncoding), input_name='roads'), ))
        if self.personDensity is not None and 'personDensity' not in already_processed:
            already_processed.add('personDensity')
            outfile.write(' personDensity=%s' % (self.gds_format_string(quote_attrib(self.personDensity).encode(ExternalEncoding), input_name='personDensity'), ))
        if self.maxCars is not None and 'maxCars' not in already_processed:
            already_processed.add('maxCars')
            outfile.write(' maxCars=%s' % (self.gds_format_string(quote_attrib(self.maxCars).encode(ExternalEncoding), input_name='maxCars'), ))
        if self.rooms is not None and 'rooms' not in already_processed:
            already_processed.add('rooms')
            outfile.write(' rooms=%s' % (self.gds_format_string(quote_attrib(self.rooms).encode(ExternalEncoding), input_name='rooms'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='simulation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='simulation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.roads is not None and 'roads' not in already_processed:
            already_processed.add('roads')
            showIndent(outfile, level)
            outfile.write('roads="%s",\n' % (self.roads,))
        if self.personDensity is not None and 'personDensity' not in already_processed:
            already_processed.add('personDensity')
            showIndent(outfile, level)
            outfile.write('personDensity="%s",\n' % (self.personDensity,))
        if self.maxCars is not None and 'maxCars' not in already_processed:
            already_processed.add('maxCars')
            showIndent(outfile, level)
            outfile.write('maxCars="%s",\n' % (self.maxCars,))
        if self.rooms is not None and 'rooms' not in already_processed:
            already_processed.add('rooms')
            showIndent(outfile, level)
            outfile.write('rooms="%s",\n' % (self.rooms,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('roads', node)
        if value is not None and 'roads' not in already_processed:
            already_processed.add('roads')
            self.roads = value
        value = find_attr_value_('personDensity', node)
        if value is not None and 'personDensity' not in already_processed:
            already_processed.add('personDensity')
            self.personDensity = value
        value = find_attr_value_('maxCars', node)
        if value is not None and 'maxCars' not in already_processed:
            already_processed.add('maxCars')
            self.maxCars = value
        value = find_attr_value_('rooms', node)
        if value is not None and 'rooms' not in already_processed:
            already_processed.add('rooms')
            self.rooms = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class simulation


class LODscale(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if LODscale.subclass:
            return LODscale.subclass(*args_, **kwargs_)
        else:
            return LODscale(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LODscale', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LODscale')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LODscale', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LODscale'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LODscale', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LODscale'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LODscale


class light(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, shadowIntensity=None, position_longitude=None, sun_altitude=None, sun_azimuth=None, diffuse=None, ssaoIntensity=None, ambient=None, position_latitude=None):
        self.original_tagname_ = None
        self.shadowIntensity = _cast(None, shadowIntensity)
        self.position_longitude = _cast(None, position_longitude)
        self.sun_altitude = _cast(None, sun_altitude)
        self.sun_azimuth = _cast(None, sun_azimuth)
        self.diffuse = _cast(None, diffuse)
        self.ssaoIntensity = _cast(None, ssaoIntensity)
        self.ambient = _cast(None, ambient)
        self.position_latitude = _cast(None, position_latitude)
    def factory(*args_, **kwargs_):
        if light.subclass:
            return light.subclass(*args_, **kwargs_)
        else:
            return light(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_shadowIntensity(self): return self.shadowIntensity
    def set_shadowIntensity(self, shadowIntensity): self.shadowIntensity = shadowIntensity
    def get_position_longitude(self): return self.position_longitude
    def set_position_longitude(self, position_longitude): self.position_longitude = position_longitude
    def get_sun_altitude(self): return self.sun_altitude
    def set_sun_altitude(self, sun_altitude): self.sun_altitude = sun_altitude
    def get_sun_azimuth(self): return self.sun_azimuth
    def set_sun_azimuth(self, sun_azimuth): self.sun_azimuth = sun_azimuth
    def get_diffuse(self): return self.diffuse
    def set_diffuse(self, diffuse): self.diffuse = diffuse
    def get_ssaoIntensity(self): return self.ssaoIntensity
    def set_ssaoIntensity(self, ssaoIntensity): self.ssaoIntensity = ssaoIntensity
    def get_ambient(self): return self.ambient
    def set_ambient(self, ambient): self.ambient = ambient
    def get_position_latitude(self): return self.position_latitude
    def set_position_latitude(self, position_latitude): self.position_latitude = position_latitude
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='light', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='light')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='light', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='light'):
        if self.shadowIntensity is not None and 'shadowIntensity' not in already_processed:
            already_processed.add('shadowIntensity')
            outfile.write(' shadowIntensity=%s' % (self.gds_format_string(quote_attrib(self.shadowIntensity).encode(ExternalEncoding), input_name='shadowIntensity'), ))
        if self.position_longitude is not None and 'position_longitude' not in already_processed:
            already_processed.add('position_longitude')
            outfile.write(' position_longitude=%s' % (self.gds_format_string(quote_attrib(self.position_longitude).encode(ExternalEncoding), input_name='position_longitude'), ))
        if self.sun_altitude is not None and 'sun_altitude' not in already_processed:
            already_processed.add('sun_altitude')
            outfile.write(' sun_altitude=%s' % (self.gds_format_string(quote_attrib(self.sun_altitude).encode(ExternalEncoding), input_name='sun_altitude'), ))
        if self.sun_azimuth is not None and 'sun_azimuth' not in already_processed:
            already_processed.add('sun_azimuth')
            outfile.write(' sun_azimuth=%s' % (self.gds_format_string(quote_attrib(self.sun_azimuth).encode(ExternalEncoding), input_name='sun_azimuth'), ))
        if self.diffuse is not None and 'diffuse' not in already_processed:
            already_processed.add('diffuse')
            outfile.write(' diffuse=%s' % (self.gds_format_string(quote_attrib(self.diffuse).encode(ExternalEncoding), input_name='diffuse'), ))
        if self.ssaoIntensity is not None and 'ssaoIntensity' not in already_processed:
            already_processed.add('ssaoIntensity')
            outfile.write(' ssaoIntensity=%s' % (self.gds_format_string(quote_attrib(self.ssaoIntensity).encode(ExternalEncoding), input_name='ssaoIntensity'), ))
        if self.ambient is not None and 'ambient' not in already_processed:
            already_processed.add('ambient')
            outfile.write(' ambient=%s' % (self.gds_format_string(quote_attrib(self.ambient).encode(ExternalEncoding), input_name='ambient'), ))
        if self.position_latitude is not None and 'position_latitude' not in already_processed:
            already_processed.add('position_latitude')
            outfile.write(' position_latitude=%s' % (self.gds_format_string(quote_attrib(self.position_latitude).encode(ExternalEncoding), input_name='position_latitude'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='light', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='light'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.shadowIntensity is not None and 'shadowIntensity' not in already_processed:
            already_processed.add('shadowIntensity')
            showIndent(outfile, level)
            outfile.write('shadowIntensity="%s",\n' % (self.shadowIntensity,))
        if self.position_longitude is not None and 'position_longitude' not in already_processed:
            already_processed.add('position_longitude')
            showIndent(outfile, level)
            outfile.write('position_longitude="%s",\n' % (self.position_longitude,))
        if self.sun_altitude is not None and 'sun_altitude' not in already_processed:
            already_processed.add('sun_altitude')
            showIndent(outfile, level)
            outfile.write('sun_altitude="%s",\n' % (self.sun_altitude,))
        if self.sun_azimuth is not None and 'sun_azimuth' not in already_processed:
            already_processed.add('sun_azimuth')
            showIndent(outfile, level)
            outfile.write('sun_azimuth="%s",\n' % (self.sun_azimuth,))
        if self.diffuse is not None and 'diffuse' not in already_processed:
            already_processed.add('diffuse')
            showIndent(outfile, level)
            outfile.write('diffuse="%s",\n' % (self.diffuse,))
        if self.ssaoIntensity is not None and 'ssaoIntensity' not in already_processed:
            already_processed.add('ssaoIntensity')
            showIndent(outfile, level)
            outfile.write('ssaoIntensity="%s",\n' % (self.ssaoIntensity,))
        if self.ambient is not None and 'ambient' not in already_processed:
            already_processed.add('ambient')
            showIndent(outfile, level)
            outfile.write('ambient="%s",\n' % (self.ambient,))
        if self.position_latitude is not None and 'position_latitude' not in already_processed:
            already_processed.add('position_latitude')
            showIndent(outfile, level)
            outfile.write('position_latitude="%s",\n' % (self.position_latitude,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('shadowIntensity', node)
        if value is not None and 'shadowIntensity' not in already_processed:
            already_processed.add('shadowIntensity')
            self.shadowIntensity = value
        value = find_attr_value_('position_longitude', node)
        if value is not None and 'position_longitude' not in already_processed:
            already_processed.add('position_longitude')
            self.position_longitude = value
        value = find_attr_value_('sun_altitude', node)
        if value is not None and 'sun_altitude' not in already_processed:
            already_processed.add('sun_altitude')
            self.sun_altitude = value
        value = find_attr_value_('sun_azimuth', node)
        if value is not None and 'sun_azimuth' not in already_processed:
            already_processed.add('sun_azimuth')
            self.sun_azimuth = value
        value = find_attr_value_('diffuse', node)
        if value is not None and 'diffuse' not in already_processed:
            already_processed.add('diffuse')
            self.diffuse = value
        value = find_attr_value_('ssaoIntensity', node)
        if value is not None and 'ssaoIntensity' not in already_processed:
            already_processed.add('ssaoIntensity')
            self.ssaoIntensity = value
        value = find_attr_value_('ambient', node)
        if value is not None and 'ambient' not in already_processed:
            already_processed.add('ambient')
            self.ambient = value
        value = find_attr_value_('position_latitude', node)
        if value is not None and 'position_latitude' not in already_processed:
            already_processed.add('position_latitude')
            self.position_latitude = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class light


class shadow(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, farplane=None, update_shadowmap=None, nearplane=None, mapsize=None, polyoffsetunits=None, polyoffsetfactor=None, mapcount=None):
        self.original_tagname_ = None
        self.farplane = _cast(None, farplane)
        self.update_shadowmap = _cast(None, update_shadowmap)
        self.nearplane = _cast(None, nearplane)
        self.mapsize = _cast(None, mapsize)
        self.polyoffsetunits = _cast(None, polyoffsetunits)
        self.polyoffsetfactor = _cast(None, polyoffsetfactor)
        self.mapcount = _cast(None, mapcount)
    def factory(*args_, **kwargs_):
        if shadow.subclass:
            return shadow.subclass(*args_, **kwargs_)
        else:
            return shadow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_farplane(self): return self.farplane
    def set_farplane(self, farplane): self.farplane = farplane
    def get_update_shadowmap(self): return self.update_shadowmap
    def set_update_shadowmap(self, update_shadowmap): self.update_shadowmap = update_shadowmap
    def get_nearplane(self): return self.nearplane
    def set_nearplane(self, nearplane): self.nearplane = nearplane
    def get_mapsize(self): return self.mapsize
    def set_mapsize(self, mapsize): self.mapsize = mapsize
    def get_polyoffsetunits(self): return self.polyoffsetunits
    def set_polyoffsetunits(self, polyoffsetunits): self.polyoffsetunits = polyoffsetunits
    def get_polyoffsetfactor(self): return self.polyoffsetfactor
    def set_polyoffsetfactor(self, polyoffsetfactor): self.polyoffsetfactor = polyoffsetfactor
    def get_mapcount(self): return self.mapcount
    def set_mapcount(self, mapcount): self.mapcount = mapcount
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='shadow', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='shadow')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='shadow', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='shadow'):
        if self.farplane is not None and 'farplane' not in already_processed:
            already_processed.add('farplane')
            outfile.write(' farplane=%s' % (self.gds_format_string(quote_attrib(self.farplane).encode(ExternalEncoding), input_name='farplane'), ))
        if self.update_shadowmap is not None and 'update_shadowmap' not in already_processed:
            already_processed.add('update_shadowmap')
            outfile.write(' update_shadowmap=%s' % (self.gds_format_string(quote_attrib(self.update_shadowmap).encode(ExternalEncoding), input_name='update_shadowmap'), ))
        if self.nearplane is not None and 'nearplane' not in already_processed:
            already_processed.add('nearplane')
            outfile.write(' nearplane=%s' % (self.gds_format_string(quote_attrib(self.nearplane).encode(ExternalEncoding), input_name='nearplane'), ))
        if self.mapsize is not None and 'mapsize' not in already_processed:
            already_processed.add('mapsize')
            outfile.write(' mapsize=%s' % (self.gds_format_string(quote_attrib(self.mapsize).encode(ExternalEncoding), input_name='mapsize'), ))
        if self.polyoffsetunits is not None and 'polyoffsetunits' not in already_processed:
            already_processed.add('polyoffsetunits')
            outfile.write(' polyoffsetunits=%s' % (self.gds_format_string(quote_attrib(self.polyoffsetunits).encode(ExternalEncoding), input_name='polyoffsetunits'), ))
        if self.polyoffsetfactor is not None and 'polyoffsetfactor' not in already_processed:
            already_processed.add('polyoffsetfactor')
            outfile.write(' polyoffsetfactor=%s' % (self.gds_format_string(quote_attrib(self.polyoffsetfactor).encode(ExternalEncoding), input_name='polyoffsetfactor'), ))
        if self.mapcount is not None and 'mapcount' not in already_processed:
            already_processed.add('mapcount')
            outfile.write(' mapcount=%s' % (self.gds_format_string(quote_attrib(self.mapcount).encode(ExternalEncoding), input_name='mapcount'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='shadow', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='shadow'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.farplane is not None and 'farplane' not in already_processed:
            already_processed.add('farplane')
            showIndent(outfile, level)
            outfile.write('farplane="%s",\n' % (self.farplane,))
        if self.update_shadowmap is not None and 'update_shadowmap' not in already_processed:
            already_processed.add('update_shadowmap')
            showIndent(outfile, level)
            outfile.write('update_shadowmap="%s",\n' % (self.update_shadowmap,))
        if self.nearplane is not None and 'nearplane' not in already_processed:
            already_processed.add('nearplane')
            showIndent(outfile, level)
            outfile.write('nearplane="%s",\n' % (self.nearplane,))
        if self.mapsize is not None and 'mapsize' not in already_processed:
            already_processed.add('mapsize')
            showIndent(outfile, level)
            outfile.write('mapsize="%s",\n' % (self.mapsize,))
        if self.polyoffsetunits is not None and 'polyoffsetunits' not in already_processed:
            already_processed.add('polyoffsetunits')
            showIndent(outfile, level)
            outfile.write('polyoffsetunits="%s",\n' % (self.polyoffsetunits,))
        if self.polyoffsetfactor is not None and 'polyoffsetfactor' not in already_processed:
            already_processed.add('polyoffsetfactor')
            showIndent(outfile, level)
            outfile.write('polyoffsetfactor="%s",\n' % (self.polyoffsetfactor,))
        if self.mapcount is not None and 'mapcount' not in already_processed:
            already_processed.add('mapcount')
            showIndent(outfile, level)
            outfile.write('mapcount="%s",\n' % (self.mapcount,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('farplane', node)
        if value is not None and 'farplane' not in already_processed:
            already_processed.add('farplane')
            self.farplane = value
        value = find_attr_value_('update_shadowmap', node)
        if value is not None and 'update_shadowmap' not in already_processed:
            already_processed.add('update_shadowmap')
            self.update_shadowmap = value
        value = find_attr_value_('nearplane', node)
        if value is not None and 'nearplane' not in already_processed:
            already_processed.add('nearplane')
            self.nearplane = value
        value = find_attr_value_('mapsize', node)
        if value is not None and 'mapsize' not in already_processed:
            already_processed.add('mapsize')
            self.mapsize = value
        value = find_attr_value_('polyoffsetunits', node)
        if value is not None and 'polyoffsetunits' not in already_processed:
            already_processed.add('polyoffsetunits')
            self.polyoffsetunits = value
        value = find_attr_value_('polyoffsetfactor', node)
        if value is not None and 'polyoffsetfactor' not in already_processed:
            already_processed.add('polyoffsetfactor')
            self.polyoffsetfactor = value
        value = find_attr_value_('mapcount', node)
        if value is not None and 'mapcount' not in already_processed:
            already_processed.add('mapcount')
            self.mapcount = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class shadow


class backFaceCulling(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, on=None):
        self.original_tagname_ = None
        self.on = _cast(None, on)
    def factory(*args_, **kwargs_):
        if backFaceCulling.subclass:
            return backFaceCulling.subclass(*args_, **kwargs_)
        else:
            return backFaceCulling(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_on(self): return self.on
    def set_on(self, on): self.on = on
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='backFaceCulling', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='backFaceCulling')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='backFaceCulling', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='backFaceCulling'):
        if self.on is not None and 'on' not in already_processed:
            already_processed.add('on')
            outfile.write(' on=%s' % (self.gds_format_string(quote_attrib(self.on).encode(ExternalEncoding), input_name='on'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='backFaceCulling', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='backFaceCulling'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.on is not None and 'on' not in already_processed:
            already_processed.add('on')
            showIndent(outfile, level)
            outfile.write('on="%s",\n' % (self.on,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('on', node)
        if value is not None and 'on' not in already_processed:
            already_processed.add('on')
            self.on = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class backFaceCulling


class preferences(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, objectRotationSnap=None, cameraParameters=None, slaveViewClearPitch=None, clip=None, simulation=None, LODscale=None, light=None, shadow=None, backFaceCulling=None):
        self.original_tagname_ = None
        self.objectRotationSnap = objectRotationSnap
        self.cameraParameters = cameraParameters
        self.slaveViewClearPitch = slaveViewClearPitch
        self.clip = clip
        self.simulation = simulation
        self.LODscale = LODscale
        self.light = light
        self.shadow = shadow
        self.backFaceCulling = backFaceCulling
    def factory(*args_, **kwargs_):
        if preferences.subclass:
            return preferences.subclass(*args_, **kwargs_)
        else:
            return preferences(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_objectRotationSnap(self): return self.objectRotationSnap
    def set_objectRotationSnap(self, objectRotationSnap): self.objectRotationSnap = objectRotationSnap
    def get_cameraParameters(self): return self.cameraParameters
    def set_cameraParameters(self, cameraParameters): self.cameraParameters = cameraParameters
    def get_slaveViewClearPitch(self): return self.slaveViewClearPitch
    def set_slaveViewClearPitch(self, slaveViewClearPitch): self.slaveViewClearPitch = slaveViewClearPitch
    def get_clip(self): return self.clip
    def set_clip(self, clip): self.clip = clip
    def get_simulation(self): return self.simulation
    def set_simulation(self, simulation): self.simulation = simulation
    def get_LODscale(self): return self.LODscale
    def set_LODscale(self, LODscale): self.LODscale = LODscale
    def get_light(self): return self.light
    def set_light(self, light): self.light = light
    def get_shadow(self): return self.shadow
    def set_shadow(self, shadow): self.shadow = shadow
    def get_backFaceCulling(self): return self.backFaceCulling
    def set_backFaceCulling(self, backFaceCulling): self.backFaceCulling = backFaceCulling
    def hasContent_(self):
        if (
            self.objectRotationSnap is not None or
            self.cameraParameters is not None or
            self.slaveViewClearPitch is not None or
            self.clip is not None or
            self.simulation is not None or
            self.LODscale is not None or
            self.light is not None or
            self.shadow is not None or
            self.backFaceCulling is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='preferences', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='preferences')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='preferences', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='preferences'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='preferences', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.objectRotationSnap is not None:
            self.objectRotationSnap.export(outfile, level, namespace_, name_='objectRotationSnap', pretty_print=pretty_print)
        if self.cameraParameters is not None:
            self.cameraParameters.export(outfile, level, namespace_, name_='cameraParameters', pretty_print=pretty_print)
        if self.slaveViewClearPitch is not None:
            self.slaveViewClearPitch.export(outfile, level, namespace_, name_='slaveViewClearPitch', pretty_print=pretty_print)
        if self.clip is not None:
            self.clip.export(outfile, level, namespace_, name_='clip', pretty_print=pretty_print)
        if self.simulation is not None:
            self.simulation.export(outfile, level, namespace_, name_='simulation', pretty_print=pretty_print)
        if self.LODscale is not None:
            self.LODscale.export(outfile, level, namespace_, name_='LODscale', pretty_print=pretty_print)
        if self.light is not None:
            self.light.export(outfile, level, namespace_, name_='light', pretty_print=pretty_print)
        if self.shadow is not None:
            self.shadow.export(outfile, level, namespace_, name_='shadow', pretty_print=pretty_print)
        if self.backFaceCulling is not None:
            self.backFaceCulling.export(outfile, level, namespace_, name_='backFaceCulling', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='preferences'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.objectRotationSnap is not None:
            showIndent(outfile, level)
            outfile.write('objectRotationSnap=model_.objectRotationSnap(\n')
            self.objectRotationSnap.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cameraParameters is not None:
            showIndent(outfile, level)
            outfile.write('cameraParameters=model_.cameraParameters(\n')
            self.cameraParameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.slaveViewClearPitch is not None:
            showIndent(outfile, level)
            outfile.write('slaveViewClearPitch=model_.slaveViewClearPitch(\n')
            self.slaveViewClearPitch.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.clip is not None:
            showIndent(outfile, level)
            outfile.write('clip=model_.clip(\n')
            self.clip.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.simulation is not None:
            showIndent(outfile, level)
            outfile.write('simulation=model_.simulation(\n')
            self.simulation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LODscale is not None:
            showIndent(outfile, level)
            outfile.write('LODscale=model_.LODscale(\n')
            self.LODscale.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.light is not None:
            showIndent(outfile, level)
            outfile.write('light=model_.light(\n')
            self.light.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.shadow is not None:
            showIndent(outfile, level)
            outfile.write('shadow=model_.shadow(\n')
            self.shadow.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.backFaceCulling is not None:
            showIndent(outfile, level)
            outfile.write('backFaceCulling=model_.backFaceCulling(\n')
            self.backFaceCulling.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'objectRotationSnap':
            obj_ = objectRotationSnap.factory()
            obj_.build(child_)
            self.objectRotationSnap = obj_
            obj_.original_tagname_ = 'objectRotationSnap'
        elif nodeName_ == 'cameraParameters':
            obj_ = cameraParameters.factory()
            obj_.build(child_)
            self.cameraParameters = obj_
            obj_.original_tagname_ = 'cameraParameters'
        elif nodeName_ == 'slaveViewClearPitch':
            obj_ = slaveViewClearPitch.factory()
            obj_.build(child_)
            self.slaveViewClearPitch = obj_
            obj_.original_tagname_ = 'slaveViewClearPitch'
        elif nodeName_ == 'clip':
            obj_ = clip.factory()
            obj_.build(child_)
            self.clip = obj_
            obj_.original_tagname_ = 'clip'
        elif nodeName_ == 'simulation':
            obj_ = simulation.factory()
            obj_.build(child_)
            self.simulation = obj_
            obj_.original_tagname_ = 'simulation'
        elif nodeName_ == 'LODscale':
            obj_ = LODscale.factory()
            obj_.build(child_)
            self.LODscale = obj_
            obj_.original_tagname_ = 'LODscale'
        elif nodeName_ == 'light':
            obj_ = light.factory()
            obj_.build(child_)
            self.light = obj_
            obj_.original_tagname_ = 'light'
        elif nodeName_ == 'shadow':
            obj_ = shadow.factory()
            obj_.build(child_)
            self.shadow = obj_
            obj_.original_tagname_ = 'shadow'
        elif nodeName_ == 'backFaceCulling':
            obj_ = backFaceCulling.factory()
            obj_.build(child_)
            self.backFaceCulling = obj_
            obj_.original_tagname_ = 'backFaceCulling'
# end class preferences


class attributes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, administrators=None, site_contexts=None, site_interpretations=None, conditions=None, object_types=None, object_interpretations=None, periods=None, reliabilitys=None, depression_types=None, decoration_types=None, depictions=None, types=None, subtypes=None, techniques=None):
        self.original_tagname_ = None
        self.administrators = administrators
        self.site_contexts = site_contexts
        self.site_interpretations = site_interpretations
        self.conditions = conditions
        self.object_types = object_types
        self.object_interpretations = object_interpretations
        self.periods = periods
        self.reliabilitys = reliabilitys
        self.depression_types = depression_types
        self.decoration_types = decoration_types
        self.depictions = depictions
        self.types = types
        self.subtypes = subtypes
        self.techniques = techniques
    def factory(*args_, **kwargs_):
        if attributes.subclass:
            return attributes.subclass(*args_, **kwargs_)
        else:
            return attributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_administrators(self): return self.administrators
    def set_administrators(self, administrators): self.administrators = administrators
    def get_site_contexts(self): return self.site_contexts
    def set_site_contexts(self, site_contexts): self.site_contexts = site_contexts
    def get_site_interpretations(self): return self.site_interpretations
    def set_site_interpretations(self, site_interpretations): self.site_interpretations = site_interpretations
    def get_conditions(self): return self.conditions
    def set_conditions(self, conditions): self.conditions = conditions
    def get_object_types(self): return self.object_types
    def set_object_types(self, object_types): self.object_types = object_types
    def get_object_interpretations(self): return self.object_interpretations
    def set_object_interpretations(self, object_interpretations): self.object_interpretations = object_interpretations
    def get_periods(self): return self.periods
    def set_periods(self, periods): self.periods = periods
    def get_reliabilitys(self): return self.reliabilitys
    def set_reliabilitys(self, reliabilitys): self.reliabilitys = reliabilitys
    def get_depression_types(self): return self.depression_types
    def set_depression_types(self, depression_types): self.depression_types = depression_types
    def get_decoration_types(self): return self.decoration_types
    def set_decoration_types(self, decoration_types): self.decoration_types = decoration_types
    def get_depictions(self): return self.depictions
    def set_depictions(self, depictions): self.depictions = depictions
    def get_types(self): return self.types
    def set_types(self, types): self.types = types
    def get_subtypes(self): return self.subtypes
    def set_subtypes(self, subtypes): self.subtypes = subtypes
    def get_techniques(self): return self.techniques
    def set_techniques(self, techniques): self.techniques = techniques
    def hasContent_(self):
        if (
            self.administrators is not None or
            self.site_contexts is not None or
            self.site_interpretations is not None or
            self.conditions is not None or
            self.object_types is not None or
            self.object_interpretations is not None or
            self.periods is not None or
            self.reliabilitys is not None or
            self.depression_types is not None or
            self.decoration_types is not None or
            self.depictions is not None or
            self.types is not None or
            self.subtypes is not None or
            self.techniques is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='attributes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attributes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='attributes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='attributes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='attributes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.administrators is not None:
            self.administrators.export(outfile, level, namespace_, name_='administrators', pretty_print=pretty_print)
        if self.site_contexts is not None:
            self.site_contexts.export(outfile, level, namespace_, name_='site_contexts', pretty_print=pretty_print)
        if self.site_interpretations is not None:
            self.site_interpretations.export(outfile, level, namespace_, name_='site_interpretations', pretty_print=pretty_print)
        if self.conditions is not None:
            self.conditions.export(outfile, level, namespace_, name_='conditions', pretty_print=pretty_print)
        if self.object_types is not None:
            self.object_types.export(outfile, level, namespace_, name_='object_types', pretty_print=pretty_print)
        if self.object_interpretations is not None:
            self.object_interpretations.export(outfile, level, namespace_, name_='object_interpretations', pretty_print=pretty_print)
        if self.periods is not None:
            self.periods.export(outfile, level, namespace_, name_='periods', pretty_print=pretty_print)
        if self.reliabilitys is not None:
            self.reliabilitys.export(outfile, level, namespace_, name_='reliabilitys', pretty_print=pretty_print)
        if self.depression_types is not None:
            self.depression_types.export(outfile, level, namespace_, name_='depression_types', pretty_print=pretty_print)
        if self.decoration_types is not None:
            self.decoration_types.export(outfile, level, namespace_, name_='decoration_types', pretty_print=pretty_print)
        if self.depictions is not None:
            self.depictions.export(outfile, level, namespace_, name_='depictions', pretty_print=pretty_print)
        if self.types is not None:
            self.types.export(outfile, level, namespace_, name_='types', pretty_print=pretty_print)
        if self.subtypes is not None:
            self.subtypes.export(outfile, level, namespace_, name_='subtypes', pretty_print=pretty_print)
        if self.techniques is not None:
            self.techniques.export(outfile, level, namespace_, name_='techniques', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='attributes'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.administrators is not None:
            showIndent(outfile, level)
            outfile.write('administrators=model_.administrators(\n')
            self.administrators.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.site_contexts is not None:
            showIndent(outfile, level)
            outfile.write('site_contexts=model_.site_contexts(\n')
            self.site_contexts.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.site_interpretations is not None:
            showIndent(outfile, level)
            outfile.write('site_interpretations=model_.site_interpretations(\n')
            self.site_interpretations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.conditions is not None:
            showIndent(outfile, level)
            outfile.write('conditions=model_.conditions(\n')
            self.conditions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.object_types is not None:
            showIndent(outfile, level)
            outfile.write('object_types=model_.object_types(\n')
            self.object_types.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.object_interpretations is not None:
            showIndent(outfile, level)
            outfile.write('object_interpretations=model_.object_interpretations(\n')
            self.object_interpretations.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.periods is not None:
            showIndent(outfile, level)
            outfile.write('periods=model_.periods(\n')
            self.periods.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reliabilitys is not None:
            showIndent(outfile, level)
            outfile.write('reliabilitys=model_.reliabilitys(\n')
            self.reliabilitys.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.depression_types is not None:
            showIndent(outfile, level)
            outfile.write('depression_types=model_.depression_types(\n')
            self.depression_types.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.decoration_types is not None:
            showIndent(outfile, level)
            outfile.write('decoration_types=model_.decoration_types(\n')
            self.decoration_types.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.depictions is not None:
            showIndent(outfile, level)
            outfile.write('depictions=model_.depictions(\n')
            self.depictions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.types is not None:
            showIndent(outfile, level)
            outfile.write('types=model_.types(\n')
            self.types.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subtypes is not None:
            showIndent(outfile, level)
            outfile.write('subtypes=model_.subtypes(\n')
            self.subtypes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.techniques is not None:
            showIndent(outfile, level)
            outfile.write('techniques=model_.techniques(\n')
            self.techniques.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'administrators':
            obj_ = administrators.factory()
            obj_.build(child_)
            self.administrators = obj_
            obj_.original_tagname_ = 'administrators'
        elif nodeName_ == 'site_contexts':
            obj_ = site_contexts.factory()
            obj_.build(child_)
            self.site_contexts = obj_
            obj_.original_tagname_ = 'site_contexts'
        elif nodeName_ == 'site_interpretations':
            obj_ = site_interpretations.factory()
            obj_.build(child_)
            self.site_interpretations = obj_
            obj_.original_tagname_ = 'site_interpretations'
        elif nodeName_ == 'conditions':
            obj_ = conditions.factory()
            obj_.build(child_)
            self.conditions = obj_
            obj_.original_tagname_ = 'conditions'
        elif nodeName_ == 'object_types':
            obj_ = object_types.factory()
            obj_.build(child_)
            self.object_types = obj_
            obj_.original_tagname_ = 'object_types'
        elif nodeName_ == 'object_interpretations':
            obj_ = object_interpretations.factory()
            obj_.build(child_)
            self.object_interpretations = obj_
            obj_.original_tagname_ = 'object_interpretations'
        elif nodeName_ == 'periods':
            obj_ = periods.factory()
            obj_.build(child_)
            self.periods = obj_
            obj_.original_tagname_ = 'periods'
        elif nodeName_ == 'reliabilitys':
            obj_ = reliabilitys.factory()
            obj_.build(child_)
            self.reliabilitys = obj_
            obj_.original_tagname_ = 'reliabilitys'
        elif nodeName_ == 'depression_types':
            obj_ = depression_types.factory()
            obj_.build(child_)
            self.depression_types = obj_
            obj_.original_tagname_ = 'depression_types'
        elif nodeName_ == 'decoration_types':
            obj_ = decoration_types.factory()
            obj_.build(child_)
            self.decoration_types = obj_
            obj_.original_tagname_ = 'decoration_types'
        elif nodeName_ == 'depictions':
            obj_ = depictions.factory()
            obj_.build(child_)
            self.depictions = obj_
            obj_.original_tagname_ = 'depictions'
        elif nodeName_ == 'types':
            obj_ = types.factory()
            obj_.build(child_)
            self.types = obj_
            obj_.original_tagname_ = 'types'
        elif nodeName_ == 'subtypes':
            obj_ = subtypes.factory()
            obj_.build(child_)
            self.subtypes = obj_
            obj_.original_tagname_ = 'subtypes'
        elif nodeName_ == 'techniques':
            obj_ = techniques.factory()
            obj_.build(child_)
            self.techniques = obj_
            obj_.original_tagname_ = 'techniques'
# end class attributes


class administrator(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if administrator.subclass:
            return administrator.subclass(*args_, **kwargs_)
        else:
            return administrator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='administrator', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='administrator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='administrator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='administrator'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='administrator', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='administrator'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class administrator


class administrators(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, administrator=None):
        self.original_tagname_ = None
        if administrator is None:
            self.administrator = []
        else:
            self.administrator = administrator
    def factory(*args_, **kwargs_):
        if administrators.subclass:
            return administrators.subclass(*args_, **kwargs_)
        else:
            return administrators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_administrator(self): return self.administrator
    def set_administrator(self, administrator): self.administrator = administrator
    def add_administrator(self, value): self.administrator.append(value)
    def insert_administrator_at(self, index, value): self.administrator.insert(index, value)
    def replace_administrator_at(self, index, value): self.administrator[index] = value
    def hasContent_(self):
        if (
            self.administrator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='administrators', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='administrators')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='administrators', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='administrators'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='administrators', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for administrator_ in self.administrator:
            administrator_.export(outfile, level, namespace_, name_='administrator', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='administrators'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('administrator=[\n')
        level += 1
        for administrator_ in self.administrator:
            showIndent(outfile, level)
            outfile.write('model_.administrator(\n')
            administrator_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'administrator':
            obj_ = administrator.factory()
            obj_.build(child_)
            self.administrator.append(obj_)
            obj_.original_tagname_ = 'administrator'
# end class administrators


class site_context(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if site_context.subclass:
            return site_context.subclass(*args_, **kwargs_)
        else:
            return site_context(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='site_context', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='site_context')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='site_context', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='site_context'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='site_context', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='site_context'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class site_context


class site_contexts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, site_context=None):
        self.original_tagname_ = None
        if site_context is None:
            self.site_context = []
        else:
            self.site_context = site_context
    def factory(*args_, **kwargs_):
        if site_contexts.subclass:
            return site_contexts.subclass(*args_, **kwargs_)
        else:
            return site_contexts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_site_context(self): return self.site_context
    def set_site_context(self, site_context): self.site_context = site_context
    def add_site_context(self, value): self.site_context.append(value)
    def insert_site_context_at(self, index, value): self.site_context.insert(index, value)
    def replace_site_context_at(self, index, value): self.site_context[index] = value
    def hasContent_(self):
        if (
            self.site_context
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='site_contexts', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='site_contexts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='site_contexts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='site_contexts'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='site_contexts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for site_context_ in self.site_context:
            site_context_.export(outfile, level, namespace_, name_='site_context', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='site_contexts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('site_context=[\n')
        level += 1
        for site_context_ in self.site_context:
            showIndent(outfile, level)
            outfile.write('model_.site_context(\n')
            site_context_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'site_context':
            obj_ = site_context.factory()
            obj_.build(child_)
            self.site_context.append(obj_)
            obj_.original_tagname_ = 'site_context'
# end class site_contexts


class site_interpretation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if site_interpretation.subclass:
            return site_interpretation.subclass(*args_, **kwargs_)
        else:
            return site_interpretation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='site_interpretation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='site_interpretation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='site_interpretation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='site_interpretation'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='site_interpretation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='site_interpretation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class site_interpretation


class site_interpretations(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, site_interpretation=None):
        self.original_tagname_ = None
        if site_interpretation is None:
            self.site_interpretation = []
        else:
            self.site_interpretation = site_interpretation
    def factory(*args_, **kwargs_):
        if site_interpretations.subclass:
            return site_interpretations.subclass(*args_, **kwargs_)
        else:
            return site_interpretations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_site_interpretation(self): return self.site_interpretation
    def set_site_interpretation(self, site_interpretation): self.site_interpretation = site_interpretation
    def add_site_interpretation(self, value): self.site_interpretation.append(value)
    def insert_site_interpretation_at(self, index, value): self.site_interpretation.insert(index, value)
    def replace_site_interpretation_at(self, index, value): self.site_interpretation[index] = value
    def hasContent_(self):
        if (
            self.site_interpretation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='site_interpretations', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='site_interpretations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='site_interpretations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='site_interpretations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='site_interpretations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for site_interpretation_ in self.site_interpretation:
            site_interpretation_.export(outfile, level, namespace_, name_='site_interpretation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='site_interpretations'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('site_interpretation=[\n')
        level += 1
        for site_interpretation_ in self.site_interpretation:
            showIndent(outfile, level)
            outfile.write('model_.site_interpretation(\n')
            site_interpretation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'site_interpretation':
            obj_ = site_interpretation.factory()
            obj_.build(child_)
            self.site_interpretation.append(obj_)
            obj_.original_tagname_ = 'site_interpretation'
# end class site_interpretations


class condition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if condition.subclass:
            return condition.subclass(*args_, **kwargs_)
        else:
            return condition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='condition', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='condition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='condition', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='condition'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='condition', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='condition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class condition


class conditions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, condition=None):
        self.original_tagname_ = None
        if condition is None:
            self.condition = []
        else:
            self.condition = condition
    def factory(*args_, **kwargs_):
        if conditions.subclass:
            return conditions.subclass(*args_, **kwargs_)
        else:
            return conditions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def add_condition(self, value): self.condition.append(value)
    def insert_condition_at(self, index, value): self.condition.insert(index, value)
    def replace_condition_at(self, index, value): self.condition[index] = value
    def hasContent_(self):
        if (
            self.condition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conditions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conditions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conditions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conditions'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='conditions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for condition_ in self.condition:
            condition_.export(outfile, level, namespace_, name_='condition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='conditions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('condition=[\n')
        level += 1
        for condition_ in self.condition:
            showIndent(outfile, level)
            outfile.write('model_.condition(\n')
            condition_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'condition':
            obj_ = condition.factory()
            obj_.build(child_)
            self.condition.append(obj_)
            obj_.original_tagname_ = 'condition'
# end class conditions


class object_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if object_type.subclass:
            return object_type.subclass(*args_, **kwargs_)
        else:
            return object_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='object_type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='object_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='object_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='object_type'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='object_type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='object_type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class object_type


class object_types(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object_type=None):
        self.original_tagname_ = None
        if object_type is None:
            self.object_type = []
        else:
            self.object_type = object_type
    def factory(*args_, **kwargs_):
        if object_types.subclass:
            return object_types.subclass(*args_, **kwargs_)
        else:
            return object_types(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_type(self): return self.object_type
    def set_object_type(self, object_type): self.object_type = object_type
    def add_object_type(self, value): self.object_type.append(value)
    def insert_object_type_at(self, index, value): self.object_type.insert(index, value)
    def replace_object_type_at(self, index, value): self.object_type[index] = value
    def hasContent_(self):
        if (
            self.object_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='object_types', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='object_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='object_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='object_types'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='object_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_type_ in self.object_type:
            object_type_.export(outfile, level, namespace_, name_='object_type', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='object_types'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('object_type=[\n')
        level += 1
        for object_type_ in self.object_type:
            showIndent(outfile, level)
            outfile.write('model_.object_type(\n')
            object_type_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_type':
            obj_ = object_type.factory()
            obj_.build(child_)
            self.object_type.append(obj_)
            obj_.original_tagname_ = 'object_type'
# end class object_types


class object_interpretation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if object_interpretation.subclass:
            return object_interpretation.subclass(*args_, **kwargs_)
        else:
            return object_interpretation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='object_interpretation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='object_interpretation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='object_interpretation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='object_interpretation'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='object_interpretation', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='object_interpretation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class object_interpretation


class object_interpretations(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object_interpretation=None):
        self.original_tagname_ = None
        if object_interpretation is None:
            self.object_interpretation = []
        else:
            self.object_interpretation = object_interpretation
    def factory(*args_, **kwargs_):
        if object_interpretations.subclass:
            return object_interpretations.subclass(*args_, **kwargs_)
        else:
            return object_interpretations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_interpretation(self): return self.object_interpretation
    def set_object_interpretation(self, object_interpretation): self.object_interpretation = object_interpretation
    def add_object_interpretation(self, value): self.object_interpretation.append(value)
    def insert_object_interpretation_at(self, index, value): self.object_interpretation.insert(index, value)
    def replace_object_interpretation_at(self, index, value): self.object_interpretation[index] = value
    def hasContent_(self):
        if (
            self.object_interpretation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='object_interpretations', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='object_interpretations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='object_interpretations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='object_interpretations'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='object_interpretations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for object_interpretation_ in self.object_interpretation:
            object_interpretation_.export(outfile, level, namespace_, name_='object_interpretation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='object_interpretations'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('object_interpretation=[\n')
        level += 1
        for object_interpretation_ in self.object_interpretation:
            showIndent(outfile, level)
            outfile.write('model_.object_interpretation(\n')
            object_interpretation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'object_interpretation':
            obj_ = object_interpretation.factory()
            obj_.build(child_)
            self.object_interpretation.append(obj_)
            obj_.original_tagname_ = 'object_interpretation'
# end class object_interpretations


class period(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if period.subclass:
            return period.subclass(*args_, **kwargs_)
        else:
            return period(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='period', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='period')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='period', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='period'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='period', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='period'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class period


class periods(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, period=None):
        self.original_tagname_ = None
        if period is None:
            self.period = []
        else:
            self.period = period
    def factory(*args_, **kwargs_):
        if periods.subclass:
            return periods.subclass(*args_, **kwargs_)
        else:
            return periods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def add_period(self, value): self.period.append(value)
    def insert_period_at(self, index, value): self.period.insert(index, value)
    def replace_period_at(self, index, value): self.period[index] = value
    def hasContent_(self):
        if (
            self.period
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='periods', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='periods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='periods'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='periods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for period_ in self.period:
            period_.export(outfile, level, namespace_, name_='period', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='periods'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('period=[\n')
        level += 1
        for period_ in self.period:
            showIndent(outfile, level)
            outfile.write('model_.period(\n')
            period_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'period':
            obj_ = period.factory()
            obj_.build(child_)
            self.period.append(obj_)
            obj_.original_tagname_ = 'period'
# end class periods


class reliability(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if reliability.subclass:
            return reliability.subclass(*args_, **kwargs_)
        else:
            return reliability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reliability', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reliability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reliability', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reliability'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='reliability', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='reliability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class reliability


class reliabilitys(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reliability=None):
        self.original_tagname_ = None
        if reliability is None:
            self.reliability = []
        else:
            self.reliability = reliability
    def factory(*args_, **kwargs_):
        if reliabilitys.subclass:
            return reliabilitys.subclass(*args_, **kwargs_)
        else:
            return reliabilitys(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reliability(self): return self.reliability
    def set_reliability(self, reliability): self.reliability = reliability
    def add_reliability(self, value): self.reliability.append(value)
    def insert_reliability_at(self, index, value): self.reliability.insert(index, value)
    def replace_reliability_at(self, index, value): self.reliability[index] = value
    def hasContent_(self):
        if (
            self.reliability
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='reliabilitys', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reliabilitys')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='reliabilitys', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='reliabilitys'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='reliabilitys', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reliability_ in self.reliability:
            reliability_.export(outfile, level, namespace_, name_='reliability', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='reliabilitys'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('reliability=[\n')
        level += 1
        for reliability_ in self.reliability:
            showIndent(outfile, level)
            outfile.write('model_.reliability(\n')
            reliability_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reliability':
            obj_ = reliability.factory()
            obj_.build(child_)
            self.reliability.append(obj_)
            obj_.original_tagname_ = 'reliability'
# end class reliabilitys


class depression_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if depression_type.subclass:
            return depression_type.subclass(*args_, **kwargs_)
        else:
            return depression_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='depression_type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='depression_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='depression_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='depression_type'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='depression_type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='depression_type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class depression_type


class depression_types(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, depression_type=None):
        self.original_tagname_ = None
        if depression_type is None:
            self.depression_type = []
        else:
            self.depression_type = depression_type
    def factory(*args_, **kwargs_):
        if depression_types.subclass:
            return depression_types.subclass(*args_, **kwargs_)
        else:
            return depression_types(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_depression_type(self): return self.depression_type
    def set_depression_type(self, depression_type): self.depression_type = depression_type
    def add_depression_type(self, value): self.depression_type.append(value)
    def insert_depression_type_at(self, index, value): self.depression_type.insert(index, value)
    def replace_depression_type_at(self, index, value): self.depression_type[index] = value
    def hasContent_(self):
        if (
            self.depression_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='depression_types', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='depression_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='depression_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='depression_types'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='depression_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for depression_type_ in self.depression_type:
            depression_type_.export(outfile, level, namespace_, name_='depression_type', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='depression_types'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('depression_type=[\n')
        level += 1
        for depression_type_ in self.depression_type:
            showIndent(outfile, level)
            outfile.write('model_.depression_type(\n')
            depression_type_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'depression_type':
            obj_ = depression_type.factory()
            obj_.build(child_)
            self.depression_type.append(obj_)
            obj_.original_tagname_ = 'depression_type'
# end class depression_types


class decoration_type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if decoration_type.subclass:
            return decoration_type.subclass(*args_, **kwargs_)
        else:
            return decoration_type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='decoration_type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='decoration_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='decoration_type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='decoration_type'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='decoration_type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='decoration_type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class decoration_type


class decoration_types(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, decoration_type=None):
        self.original_tagname_ = None
        if decoration_type is None:
            self.decoration_type = []
        else:
            self.decoration_type = decoration_type
    def factory(*args_, **kwargs_):
        if decoration_types.subclass:
            return decoration_types.subclass(*args_, **kwargs_)
        else:
            return decoration_types(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_decoration_type(self): return self.decoration_type
    def set_decoration_type(self, decoration_type): self.decoration_type = decoration_type
    def add_decoration_type(self, value): self.decoration_type.append(value)
    def insert_decoration_type_at(self, index, value): self.decoration_type.insert(index, value)
    def replace_decoration_type_at(self, index, value): self.decoration_type[index] = value
    def hasContent_(self):
        if (
            self.decoration_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='decoration_types', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='decoration_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='decoration_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='decoration_types'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='decoration_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for decoration_type_ in self.decoration_type:
            decoration_type_.export(outfile, level, namespace_, name_='decoration_type', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='decoration_types'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('decoration_type=[\n')
        level += 1
        for decoration_type_ in self.decoration_type:
            showIndent(outfile, level)
            outfile.write('model_.decoration_type(\n')
            decoration_type_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'decoration_type':
            obj_ = decoration_type.factory()
            obj_.build(child_)
            self.decoration_type.append(obj_)
            obj_.original_tagname_ = 'decoration_type'
# end class decoration_types


class depiction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if depiction.subclass:
            return depiction.subclass(*args_, **kwargs_)
        else:
            return depiction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='depiction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='depiction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='depiction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='depiction'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='depiction', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='depiction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class depiction


class depictions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, depiction=None):
        self.original_tagname_ = None
        if depiction is None:
            self.depiction = []
        else:
            self.depiction = depiction
    def factory(*args_, **kwargs_):
        if depictions.subclass:
            return depictions.subclass(*args_, **kwargs_)
        else:
            return depictions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_depiction(self): return self.depiction
    def set_depiction(self, depiction): self.depiction = depiction
    def add_depiction(self, value): self.depiction.append(value)
    def insert_depiction_at(self, index, value): self.depiction.insert(index, value)
    def replace_depiction_at(self, index, value): self.depiction[index] = value
    def hasContent_(self):
        if (
            self.depiction
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='depictions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='depictions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='depictions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='depictions'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='depictions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for depiction_ in self.depiction:
            depiction_.export(outfile, level, namespace_, name_='depiction', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='depictions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('depiction=[\n')
        level += 1
        for depiction_ in self.depiction:
            showIndent(outfile, level)
            outfile.write('model_.depiction(\n')
            depiction_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'depiction':
            obj_ = depiction.factory()
            obj_.build(child_)
            self.depiction.append(obj_)
            obj_.original_tagname_ = 'depiction'
# end class depictions


class type_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='type'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class type_


class types(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None):
        self.original_tagname_ = None
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
    def factory(*args_, **kwargs_):
        if types.subclass:
            return types.subclass(*args_, **kwargs_)
        else:
            return types(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type_at(self, index, value): self.type_.insert(index, value)
    def replace_type_at(self, index, value): self.type_[index] = value
    def hasContent_(self):
        if (
            self.type_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='types', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='types'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='types'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.type_(\n')
            type_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.type_.append(obj_)
            obj_.original_tagname_ = 'type'
# end class types


class subtype(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if subtype.subclass:
            return subtype.subclass(*args_, **kwargs_)
        else:
            return subtype(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='subtype', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subtype')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='subtype', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='subtype'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='subtype', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='subtype'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subtype


class subtypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, subtype=None):
        self.original_tagname_ = None
        if subtype is None:
            self.subtype = []
        else:
            self.subtype = subtype
    def factory(*args_, **kwargs_):
        if subtypes.subclass:
            return subtypes.subclass(*args_, **kwargs_)
        else:
            return subtypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subtype(self): return self.subtype
    def set_subtype(self, subtype): self.subtype = subtype
    def add_subtype(self, value): self.subtype.append(value)
    def insert_subtype_at(self, index, value): self.subtype.insert(index, value)
    def replace_subtype_at(self, index, value): self.subtype[index] = value
    def hasContent_(self):
        if (
            self.subtype
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='subtypes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subtypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='subtypes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='subtypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subtypes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for subtype_ in self.subtype:
            subtype_.export(outfile, level, namespace_, name_='subtype', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='subtypes'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subtype=[\n')
        level += 1
        for subtype_ in self.subtype:
            showIndent(outfile, level)
            outfile.write('model_.subtype(\n')
            subtype_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subtype':
            obj_ = subtype.factory()
            obj_.build(child_)
            self.subtype.append(obj_)
            obj_.original_tagname_ = 'subtype'
# end class subtypes


class technique(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if technique.subclass:
            return technique.subclass(*args_, **kwargs_)
        else:
            return technique(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='technique', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='technique')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='technique', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='technique'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='technique', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='technique'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class technique


class techniques(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, technique=None):
        self.original_tagname_ = None
        if technique is None:
            self.technique = []
        else:
            self.technique = technique
    def factory(*args_, **kwargs_):
        if techniques.subclass:
            return techniques.subclass(*args_, **kwargs_)
        else:
            return techniques(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_technique(self): return self.technique
    def set_technique(self, technique): self.technique = technique
    def add_technique(self, value): self.technique.append(value)
    def insert_technique_at(self, index, value): self.technique.insert(index, value)
    def replace_technique_at(self, index, value): self.technique[index] = value
    def hasContent_(self):
        if (
            self.technique
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='techniques', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='techniques')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='techniques', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='techniques'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='techniques', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for technique_ in self.technique:
            technique_.export(outfile, level, namespace_, name_='technique', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='techniques'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('technique=[\n')
        level += 1
        for technique_ in self.technique:
            showIndent(outfile, level)
            outfile.write('model_.technique(\n')
            technique_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'technique':
            obj_ = technique.factory()
            obj_.build(child_)
            self.technique.append(obj_)
            obj_.original_tagname_ = 'technique'
# end class techniques


class staticObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, url=None):
        self.original_tagname_ = None
        self.url = _cast(None, url)
    def factory(*args_, **kwargs_):
        if staticObject.subclass:
            return staticObject.subclass(*args_, **kwargs_)
        else:
            return staticObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='staticObject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='staticObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='staticObject', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='staticObject'):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='staticObject', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='staticObject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            showIndent(outfile, level)
            outfile.write('url="%s",\n' % (self.url,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class staticObject


class staticObjects(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, staticObject=None):
        self.original_tagname_ = None
        if staticObject is None:
            self.staticObject = []
        else:
            self.staticObject = staticObject
    def factory(*args_, **kwargs_):
        if staticObjects.subclass:
            return staticObjects.subclass(*args_, **kwargs_)
        else:
            return staticObjects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_staticObject(self): return self.staticObject
    def set_staticObject(self, staticObject): self.staticObject = staticObject
    def add_staticObject(self, value): self.staticObject.append(value)
    def insert_staticObject_at(self, index, value): self.staticObject.insert(index, value)
    def replace_staticObject_at(self, index, value): self.staticObject[index] = value
    def hasContent_(self):
        if (
            self.staticObject
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='staticObjects', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='staticObjects')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='staticObjects', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='staticObjects'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='staticObjects', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for staticObject_ in self.staticObject:
            staticObject_.export(outfile, level, namespace_, name_='staticObject', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='staticObjects'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('staticObject=[\n')
        level += 1
        for staticObject_ in self.staticObject:
            showIndent(outfile, level)
            outfile.write('model_.staticObject(\n')
            staticObject_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'staticObject':
            obj_ = staticObject.factory()
            obj_.build(child_)
            self.staticObject.append(obj_)
            obj_.original_tagname_ = 'staticObject'
# end class staticObjects


class setting(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, h=None, castShadow=None, p=None, r=None, xs=None, y=None, x=None, ys=None, z=None, zs=None):
        self.original_tagname_ = None
        self.h = _cast(None, h)
        self.castShadow = _cast(None, castShadow)
        self.p = _cast(None, p)
        self.r = _cast(None, r)
        self.xs = _cast(None, xs)
        self.y = _cast(None, y)
        self.x = _cast(None, x)
        self.ys = _cast(None, ys)
        self.z = _cast(None, z)
        self.zs = _cast(None, zs)
    def factory(*args_, **kwargs_):
        if setting.subclass:
            return setting.subclass(*args_, **kwargs_)
        else:
            return setting(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_h(self): return self.h
    def set_h(self, h): self.h = h
    def get_castShadow(self): return self.castShadow
    def set_castShadow(self, castShadow): self.castShadow = castShadow
    def get_p(self): return self.p
    def set_p(self, p): self.p = p
    def get_r(self): return self.r
    def set_r(self, r): self.r = r
    def get_xs(self): return self.xs
    def set_xs(self, xs): self.xs = xs
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_ys(self): return self.ys
    def set_ys(self, ys): self.ys = ys
    def get_z(self): return self.z
    def set_z(self, z): self.z = z
    def get_zs(self): return self.zs
    def set_zs(self, zs): self.zs = zs
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='setting', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='setting')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='setting', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='setting'):
        if self.h is not None and 'h' not in already_processed:
            already_processed.add('h')
            outfile.write(' h=%s' % (self.gds_format_string(quote_attrib(self.h).encode(ExternalEncoding), input_name='h'), ))
        if self.castShadow is not None and 'castShadow' not in already_processed:
            already_processed.add('castShadow')
            outfile.write(' castShadow=%s' % (self.gds_format_string(quote_attrib(self.castShadow).encode(ExternalEncoding), input_name='castShadow'), ))
        if self.p is not None and 'p' not in already_processed:
            already_processed.add('p')
            outfile.write(' p=%s' % (self.gds_format_string(quote_attrib(self.p).encode(ExternalEncoding), input_name='p'), ))
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            outfile.write(' r=%s' % (self.gds_format_string(quote_attrib(self.r).encode(ExternalEncoding), input_name='r'), ))
        if self.xs is not None and 'xs' not in already_processed:
            already_processed.add('xs')
            outfile.write(' xs=%s' % (self.gds_format_string(quote_attrib(self.xs).encode(ExternalEncoding), input_name='xs'), ))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y=%s' % (self.gds_format_string(quote_attrib(self.y).encode(ExternalEncoding), input_name='y'), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x=%s' % (self.gds_format_string(quote_attrib(self.x).encode(ExternalEncoding), input_name='x'), ))
        if self.ys is not None and 'ys' not in already_processed:
            already_processed.add('ys')
            outfile.write(' ys=%s' % (self.gds_format_string(quote_attrib(self.ys).encode(ExternalEncoding), input_name='ys'), ))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            outfile.write(' z=%s' % (self.gds_format_string(quote_attrib(self.z).encode(ExternalEncoding), input_name='z'), ))
        if self.zs is not None and 'zs' not in already_processed:
            already_processed.add('zs')
            outfile.write(' zs=%s' % (self.gds_format_string(quote_attrib(self.zs).encode(ExternalEncoding), input_name='zs'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='setting', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='setting'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.h is not None and 'h' not in already_processed:
            already_processed.add('h')
            showIndent(outfile, level)
            outfile.write('h="%s",\n' % (self.h,))
        if self.castShadow is not None and 'castShadow' not in already_processed:
            already_processed.add('castShadow')
            showIndent(outfile, level)
            outfile.write('castShadow="%s",\n' % (self.castShadow,))
        if self.p is not None and 'p' not in already_processed:
            already_processed.add('p')
            showIndent(outfile, level)
            outfile.write('p="%s",\n' % (self.p,))
        if self.r is not None and 'r' not in already_processed:
            already_processed.add('r')
            showIndent(outfile, level)
            outfile.write('r="%s",\n' % (self.r,))
        if self.xs is not None and 'xs' not in already_processed:
            already_processed.add('xs')
            showIndent(outfile, level)
            outfile.write('xs="%s",\n' % (self.xs,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y="%s",\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x="%s",\n' % (self.x,))
        if self.ys is not None and 'ys' not in already_processed:
            already_processed.add('ys')
            showIndent(outfile, level)
            outfile.write('ys="%s",\n' % (self.ys,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.add('z')
            showIndent(outfile, level)
            outfile.write('z="%s",\n' % (self.z,))
        if self.zs is not None and 'zs' not in already_processed:
            already_processed.add('zs')
            showIndent(outfile, level)
            outfile.write('zs="%s",\n' % (self.zs,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('h', node)
        if value is not None and 'h' not in already_processed:
            already_processed.add('h')
            self.h = value
        value = find_attr_value_('castShadow', node)
        if value is not None and 'castShadow' not in already_processed:
            already_processed.add('castShadow')
            self.castShadow = value
        value = find_attr_value_('p', node)
        if value is not None and 'p' not in already_processed:
            already_processed.add('p')
            self.p = value
        value = find_attr_value_('r', node)
        if value is not None and 'r' not in already_processed:
            already_processed.add('r')
            self.r = value
        value = find_attr_value_('xs', node)
        if value is not None and 'xs' not in already_processed:
            already_processed.add('xs')
            self.xs = value
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            self.y = value
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            self.x = value
        value = find_attr_value_('ys', node)
        if value is not None and 'ys' not in already_processed:
            already_processed.add('ys')
            self.ys = value
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.add('z')
            self.z = value
        value = find_attr_value_('zs', node)
        if value is not None and 'zs' not in already_processed:
            already_processed.add('zs')
            self.zs = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class setting


class activeObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Font=None, outline=None, labelText=None, labelColorRed=None, labelColorGreen=None, labelRotateScreen=None, labelColorBlue=None, uniqueName=None, prototype=None, setting=None):
        self.original_tagname_ = None
        self.Font = _cast(None, Font)
        self.outline = _cast(None, outline)
        self.labelText = _cast(None, labelText)
        self.labelColorRed = _cast(None, labelColorRed)
        self.labelColorGreen = _cast(None, labelColorGreen)
        self.labelRotateScreen = _cast(None, labelRotateScreen)
        self.labelColorBlue = _cast(None, labelColorBlue)
        self.uniqueName = _cast(None, uniqueName)
        self.prototype = _cast(None, prototype)
        self.setting = setting
    def factory(*args_, **kwargs_):
        if activeObject.subclass:
            return activeObject.subclass(*args_, **kwargs_)
        else:
            return activeObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_setting(self): return self.setting
    def set_setting(self, setting): self.setting = setting
    def get_Font(self): return self.Font
    def set_Font(self, Font): self.Font = Font
    def get_outline(self): return self.outline
    def set_outline(self, outline): self.outline = outline
    def get_labelText(self): return self.labelText
    def set_labelText(self, labelText): self.labelText = labelText
    def get_labelColorRed(self): return self.labelColorRed
    def set_labelColorRed(self, labelColorRed): self.labelColorRed = labelColorRed
    def get_labelColorGreen(self): return self.labelColorGreen
    def set_labelColorGreen(self, labelColorGreen): self.labelColorGreen = labelColorGreen
    def get_labelRotateScreen(self): return self.labelRotateScreen
    def set_labelRotateScreen(self, labelRotateScreen): self.labelRotateScreen = labelRotateScreen
    def get_labelColorBlue(self): return self.labelColorBlue
    def set_labelColorBlue(self, labelColorBlue): self.labelColorBlue = labelColorBlue
    def get_uniqueName(self): return self.uniqueName
    def set_uniqueName(self, uniqueName): self.uniqueName = uniqueName
    def get_prototype(self): return self.prototype
    def set_prototype(self, prototype): self.prototype = prototype
    def hasContent_(self):
        if (
            self.setting is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='activeObject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activeObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='activeObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='activeObject'):
        if self.Font is not None and 'Font' not in already_processed:
            already_processed.add('Font')
            outfile.write(' Font=%s' % (self.gds_format_string(quote_attrib(self.Font).encode(ExternalEncoding), input_name='Font'), ))
        if self.outline is not None and 'outline' not in already_processed:
            already_processed.add('outline')
            outfile.write(' outline=%s' % (self.gds_format_string(quote_attrib(self.outline).encode(ExternalEncoding), input_name='outline'), ))
        if self.labelText is not None and 'labelText' not in already_processed:
            already_processed.add('labelText')
            outfile.write(' labelText=%s' % (self.gds_format_string(quote_attrib(self.labelText).encode(ExternalEncoding), input_name='labelText'), ))
        if self.labelColorRed is not None and 'labelColorRed' not in already_processed:
            already_processed.add('labelColorRed')
            outfile.write(' labelColorRed=%s' % (self.gds_format_string(quote_attrib(self.labelColorRed).encode(ExternalEncoding), input_name='labelColorRed'), ))
        if self.labelColorGreen is not None and 'labelColorGreen' not in already_processed:
            already_processed.add('labelColorGreen')
            outfile.write(' labelColorGreen=%s' % (self.gds_format_string(quote_attrib(self.labelColorGreen).encode(ExternalEncoding), input_name='labelColorGreen'), ))
        if self.labelRotateScreen is not None and 'labelRotateScreen' not in already_processed:
            already_processed.add('labelRotateScreen')
            outfile.write(' labelRotateScreen=%s' % (self.gds_format_string(quote_attrib(self.labelRotateScreen).encode(ExternalEncoding), input_name='labelRotateScreen'), ))
        if self.labelColorBlue is not None and 'labelColorBlue' not in already_processed:
            already_processed.add('labelColorBlue')
            outfile.write(' labelColorBlue=%s' % (self.gds_format_string(quote_attrib(self.labelColorBlue).encode(ExternalEncoding), input_name='labelColorBlue'), ))
        if self.uniqueName is not None and 'uniqueName' not in already_processed:
            already_processed.add('uniqueName')
            outfile.write(' uniqueName=%s' % (self.gds_format_string(quote_attrib(self.uniqueName).encode(ExternalEncoding), input_name='uniqueName'), ))
        if self.prototype is not None and 'prototype' not in already_processed:
            already_processed.add('prototype')
            outfile.write(' prototype=%s' % (self.gds_format_string(quote_attrib(self.prototype).encode(ExternalEncoding), input_name='prototype'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='activeObject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.setting is not None:
            self.setting.export(outfile, level, namespace_, name_='setting', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='activeObject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Font is not None and 'Font' not in already_processed:
            already_processed.add('Font')
            showIndent(outfile, level)
            outfile.write('Font="%s",\n' % (self.Font,))
        if self.outline is not None and 'outline' not in already_processed:
            already_processed.add('outline')
            showIndent(outfile, level)
            outfile.write('outline="%s",\n' % (self.outline,))
        if self.labelText is not None and 'labelText' not in already_processed:
            already_processed.add('labelText')
            showIndent(outfile, level)
            outfile.write('labelText="%s",\n' % (self.labelText,))
        if self.labelColorRed is not None and 'labelColorRed' not in already_processed:
            already_processed.add('labelColorRed')
            showIndent(outfile, level)
            outfile.write('labelColorRed="%s",\n' % (self.labelColorRed,))
        if self.labelColorGreen is not None and 'labelColorGreen' not in already_processed:
            already_processed.add('labelColorGreen')
            showIndent(outfile, level)
            outfile.write('labelColorGreen="%s",\n' % (self.labelColorGreen,))
        if self.labelRotateScreen is not None and 'labelRotateScreen' not in already_processed:
            already_processed.add('labelRotateScreen')
            showIndent(outfile, level)
            outfile.write('labelRotateScreen="%s",\n' % (self.labelRotateScreen,))
        if self.labelColorBlue is not None and 'labelColorBlue' not in already_processed:
            already_processed.add('labelColorBlue')
            showIndent(outfile, level)
            outfile.write('labelColorBlue="%s",\n' % (self.labelColorBlue,))
        if self.uniqueName is not None and 'uniqueName' not in already_processed:
            already_processed.add('uniqueName')
            showIndent(outfile, level)
            outfile.write('uniqueName="%s",\n' % (self.uniqueName,))
        if self.prototype is not None and 'prototype' not in already_processed:
            already_processed.add('prototype')
            showIndent(outfile, level)
            outfile.write('prototype="%s",\n' % (self.prototype,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.setting is not None:
            showIndent(outfile, level)
            outfile.write('setting=model_.setting(\n')
            self.setting.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Font', node)
        if value is not None and 'Font' not in already_processed:
            already_processed.add('Font')
            self.Font = value
        value = find_attr_value_('outline', node)
        if value is not None and 'outline' not in already_processed:
            already_processed.add('outline')
            self.outline = value
        value = find_attr_value_('labelText', node)
        if value is not None and 'labelText' not in already_processed:
            already_processed.add('labelText')
            self.labelText = value
        value = find_attr_value_('labelColorRed', node)
        if value is not None and 'labelColorRed' not in already_processed:
            already_processed.add('labelColorRed')
            self.labelColorRed = value
        value = find_attr_value_('labelColorGreen', node)
        if value is not None and 'labelColorGreen' not in already_processed:
            already_processed.add('labelColorGreen')
            self.labelColorGreen = value
        value = find_attr_value_('labelRotateScreen', node)
        if value is not None and 'labelRotateScreen' not in already_processed:
            already_processed.add('labelRotateScreen')
            self.labelRotateScreen = value
        value = find_attr_value_('labelColorBlue', node)
        if value is not None and 'labelColorBlue' not in already_processed:
            already_processed.add('labelColorBlue')
            self.labelColorBlue = value
        value = find_attr_value_('uniqueName', node)
        if value is not None and 'uniqueName' not in already_processed:
            already_processed.add('uniqueName')
            self.uniqueName = value
        value = find_attr_value_('prototype', node)
        if value is not None and 'prototype' not in already_processed:
            already_processed.add('prototype')
            self.prototype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'setting':
            obj_ = setting.factory()
            obj_.build(child_)
            self.setting = obj_
            obj_.original_tagname_ = 'setting'
# end class activeObject


class layer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, activeObject=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        if activeObject is None:
            self.activeObject = []
        else:
            self.activeObject = activeObject
    def factory(*args_, **kwargs_):
        if layer.subclass:
            return layer.subclass(*args_, **kwargs_)
        else:
            return layer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_activeObject(self): return self.activeObject
    def set_activeObject(self, activeObject): self.activeObject = activeObject
    def add_activeObject(self, value): self.activeObject.append(value)
    def insert_activeObject_at(self, index, value): self.activeObject.insert(index, value)
    def replace_activeObject_at(self, index, value): self.activeObject[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            self.activeObject
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='layer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='layer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='layer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='layer'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='layer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for activeObject_ in self.activeObject:
            activeObject_.export(outfile, level, namespace_, name_='activeObject', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='layer'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('activeObject=[\n')
        level += 1
        for activeObject_ in self.activeObject:
            showIndent(outfile, level)
            outfile.write('model_.activeObject(\n')
            activeObject_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'activeObject':
            obj_ = activeObject.factory()
            obj_.build(child_)
            self.activeObject.append(obj_)
            obj_.original_tagname_ = 'activeObject'
# end class layer


class activeObjects(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, layer=None):
        self.original_tagname_ = None
        if layer is None:
            self.layer = []
        else:
            self.layer = layer
    def factory(*args_, **kwargs_):
        if activeObjects.subclass:
            return activeObjects.subclass(*args_, **kwargs_)
        else:
            return activeObjects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_layer(self): return self.layer
    def set_layer(self, layer): self.layer = layer
    def add_layer(self, value): self.layer.append(value)
    def insert_layer_at(self, index, value): self.layer.insert(index, value)
    def replace_layer_at(self, index, value): self.layer[index] = value
    def hasContent_(self):
        if (
            self.layer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='activeObjects', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activeObjects')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='activeObjects', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='activeObjects'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='activeObjects', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for layer_ in self.layer:
            layer_.export(outfile, level, namespace_, name_='layer', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='activeObjects'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('layer=[\n')
        level += 1
        for layer_ in self.layer:
            showIndent(outfile, level)
            outfile.write('model_.layer(\n')
            layer_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'layer':
            obj_ = layer.factory()
            obj_.build(child_)
            self.layer.append(obj_)
            obj_.original_tagname_ = 'layer'
# end class activeObjects


class osgRCconfiguration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, objectLibrary=None, cameras=None, preferences=None, attributes=None, staticObjects=None, activeObjects=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        if objectLibrary is None:
            self.objectLibrary = []
        else:
            self.objectLibrary = objectLibrary
        self.cameras = cameras
        self.preferences = preferences
        self.attributes = attributes
        self.staticObjects = staticObjects
        self.activeObjects = activeObjects
    def factory(*args_, **kwargs_):
        if osgRCconfiguration.subclass:
            return osgRCconfiguration.subclass(*args_, **kwargs_)
        else:
            return osgRCconfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_objectLibrary(self): return self.objectLibrary
    def set_objectLibrary(self, objectLibrary): self.objectLibrary = objectLibrary
    def add_objectLibrary(self, value): self.objectLibrary.append(value)
    def insert_objectLibrary_at(self, index, value): self.objectLibrary.insert(index, value)
    def replace_objectLibrary_at(self, index, value): self.objectLibrary[index] = value
    def get_cameras(self): return self.cameras
    def set_cameras(self, cameras): self.cameras = cameras
    def get_preferences(self): return self.preferences
    def set_preferences(self, preferences): self.preferences = preferences
    def get_attributes(self): return self.attributes
    def set_attributes(self, attributes): self.attributes = attributes
    def get_staticObjects(self): return self.staticObjects
    def set_staticObjects(self, staticObjects): self.staticObjects = staticObjects
    def get_activeObjects(self): return self.activeObjects
    def set_activeObjects(self, activeObjects): self.activeObjects = activeObjects
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.objectLibrary or
            self.cameras is not None or
            self.preferences is not None or
            self.attributes is not None or
            self.staticObjects is not None or
            self.activeObjects is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='osgRCconfiguration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='osgRCconfiguration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='osgRCconfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='osgRCconfiguration'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='osgRCconfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for objectLibrary_ in self.objectLibrary:
            objectLibrary_.export(outfile, level, namespace_, name_='objectLibrary', pretty_print=pretty_print)
        if self.cameras is not None:
            self.cameras.export(outfile, level, namespace_, name_='cameras', pretty_print=pretty_print)
        if self.preferences is not None:
            self.preferences.export(outfile, level, namespace_, name_='preferences', pretty_print=pretty_print)
        if self.attributes is not None:
            self.attributes.export(outfile, level, namespace_, name_='attributes', pretty_print=pretty_print)
        if self.staticObjects is not None:
            self.staticObjects.export(outfile, level, namespace_, name_='staticObjects', pretty_print=pretty_print)
        if self.activeObjects is not None:
            self.activeObjects.export(outfile, level, namespace_, name_='activeObjects', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='osgRCconfiguration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('objectLibrary=[\n')
        level += 1
        for objectLibrary_ in self.objectLibrary:
            showIndent(outfile, level)
            outfile.write('model_.objectLibrary(\n')
            objectLibrary_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.cameras is not None:
            showIndent(outfile, level)
            outfile.write('cameras=model_.cameras(\n')
            self.cameras.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.preferences is not None:
            showIndent(outfile, level)
            outfile.write('preferences=model_.preferences(\n')
            self.preferences.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.attributes is not None:
            showIndent(outfile, level)
            outfile.write('attributes=model_.attributes(\n')
            self.attributes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.staticObjects is not None:
            showIndent(outfile, level)
            outfile.write('staticObjects=model_.staticObjects(\n')
            self.staticObjects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.activeObjects is not None:
            showIndent(outfile, level)
            outfile.write('activeObjects=model_.activeObjects(\n')
            self.activeObjects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'objectLibrary':
            obj_ = objectLibrary.factory()
            obj_.build(child_)
            self.objectLibrary.append(obj_)
            obj_.original_tagname_ = 'objectLibrary'
        elif nodeName_ == 'cameras':
            obj_ = cameras.factory()
            obj_.build(child_)
            self.cameras = obj_
            obj_.original_tagname_ = 'cameras'
        elif nodeName_ == 'preferences':
            obj_ = preferences.factory()
            obj_.build(child_)
            self.preferences = obj_
            obj_.original_tagname_ = 'preferences'
        elif nodeName_ == 'attributes':
            obj_ = attributes.factory()
            obj_.build(child_)
            self.attributes = obj_
            obj_.original_tagname_ = 'attributes'
        elif nodeName_ == 'staticObjects':
            obj_ = staticObjects.factory()
            obj_.build(child_)
            self.staticObjects = obj_
            obj_.original_tagname_ = 'staticObjects'
        elif nodeName_ == 'activeObjects':
            obj_ = activeObjects.factory()
            obj_.build(child_)
            self.activeObjects = obj_
            obj_.original_tagname_ = 'activeObjects'
# end class osgRCconfiguration


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'objectLibrary'
        rootClass = objectLibrary
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='',
##             pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'objectLibrary'
        rootClass = objectLibrary
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
##     if not silence:
##         content = etree_.tostring(
##             rootElement, pretty_print=True,
##             xml_declaration=True, encoding="utf-8")
##         sys.stdout.write(content)
##         sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'objectLibrary'
        rootClass = objectLibrary
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'objectLibrary'
        rootClass = objectLibrary
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     if not silence:
##         sys.stdout.write('#from viewer_conf_api import *\n\n')
##         sys.stdout.write('import viewer_conf_api as model_\n\n')
##         sys.stdout.write('rootObj = model_.rootClass(\n')
##         rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##         sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "LODscale",
    "activeObject",
    "activeObjects",
    "administrator",
    "administrators",
    "attributes",
    "backFaceCulling",
    "camera",
    "cameraParameters",
    "cameras",
    "clip",
    "condition",
    "conditions",
    "decoration_type",
    "decoration_types",
    "depiction",
    "depictions",
    "depression_type",
    "depression_types",
    "flySmoothlyToCameras",
    "keysForwardBackward",
    "keysLeftRight",
    "keysVerticalUpDown",
    "layer",
    "light",
    "mouse",
    "objectLibrary",
    "objectRotationSnap",
    "object_interpretation",
    "object_interpretations",
    "object_type",
    "object_types",
    "osgRCconfiguration",
    "period",
    "periods",
    "preferences",
    "reliability",
    "reliabilitys",
    "screen",
    "setting",
    "shadow",
    "simulation",
    "site_context",
    "site_contexts",
    "site_interpretation",
    "site_interpretations",
    "slaveViewClearPitch",
    "softBrake",
    "staticObject",
    "staticObjects",
    "subtype",
    "subtypes",
    "technique",
    "techniques",
    "type_",
    "types",
    "walkMode"
]

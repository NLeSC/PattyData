#!/usr/bin/env python
################################################################################
#    Created by Oscar Martinez                                                 #
#    o.rubi@esciencecenter.nl                                                  #
################################################################################
import os, optparse, psycopg2, time, re, multiprocessing, glob, logging, shutil, subprocess
import utils 

# The data for VIAAPPIA must follow certain data structure.
# The DATA folder must have the following structure (the OSG folder and its contents are generated by this script):
#
# DATA
#  |- PC
#  |   |- BACKGROUND
#  |   \- SITES       
#  |- MESHES
#  |   |- CURR
#  |   \- ARCH_RECONS
#  |- PICTURES
#  |   |- CURR
#  |   \- HIST
#  |
#  \- OSG                  
#      |- PC
#      |   |- BACKGROUND
#      |   \- SITES
#      |- MESHES
#      |   |- CURR
#      |   \- ARCH_RECONS
#      |- PICTURES
#      |   |- CURR
#      |   \- HIST
#      |- DOMES
#      \- BOUNDINGS
#
# The folders related to the sites, i.e. all the ones in PICTURES, 
# MESHES and the ones in PC/SITES must contain subfolders which names are the IDs of the sites. 
# Within each site folder we can put the several files (LAS and pictures). 
# In case of the meshes, for each mesh there must be a subfolder  
#
# About the names of the background folders, they can not contain dots, so valid names are 
# for example DRIVE_1_V3
#
# About the LAS files of the sites: It must have following pattern:
# ????[_8bitcolor][_aligned_BGNAME].las
# where [_8bitcolor] is optional and indicates that LAS file has color in 8 bit
#       [_aligned_BGNAME] is optional and indicates that LAS file is aligned 
#                         using BGNAME and BGNAME must be a background  
#                         contained in the background folders  
# 
# About the Meshes subfolders, each one must have a name following pattern:
# ????[_aligned_BGNAME]
# where [_aligned_BGNAME] is optional and indicates that mesh is aligned 
#                         using BGNAME and BGNAME must be a background  
#                         contained in the background folders  

PC_EXTENSIONS = ('las', 'laz')
CONVERTER_COMMAND = 'ViaAppia'
DEFAULT_MODE = 'bsmp'
LOG_LEVELS = ('DEBUG','INFO','WARNING','ERROR')
DEFAULT_LOG_LEVEL = LOG_LEVELS[0]

# Get time when we start the update process
initialTime = utils.getCurrentTime()
#Declare variable for global connection to DB
connection = None

def main(opts):
    # Set logging
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', datefmt="%Y/%m/%d/%H:%M:%S", level=getattr(logging, opts.log))
    # Establish connection with DB
    global connection
    connection = psycopg2.connect(utils.postgresConnectString(opts.dbname, opts.dbuser, opts.dbpass, opts.dbhost, opts.dbport, False))
    
    dataAbsPath = os.path.abspath(opts.data)
    osgAbsPath = os.path.abspath(opts.osg)
    # Paths for the data
    pcAbsPath = os.path.join(dataAbsPath,'PC')
    osgPCAbsPath = os.path.join(osgAbsPath, 'PC')
    
    backgroundsAbsPath = os.path.join(pcAbsPath,'BACKGROUND')
    osgBackgroundsAbsPath = os.path.join(osgPCAbsPath,'BACKGROUND')
    if 'b' in opts.mode:
        processPCBackgrounds(backgroundsAbsPath,osgBackgroundsAbsPath)
    if 's' in opts.mode:
        processSites('pc', os.path.join(pcAbsPath,'SITES'), os.path.join(osgPCAbsPath,'SITES'), backgroundsAbsPath, True)
    if 'm' in opts.mode:
        for (meshType,clean) in (('CURR', False), ('ARCH_RECONS',True)):
            processSites('mesh', os.path.join(os.path.join(dataAbsPath,'MESHES'), meshType), 
                                 os.path.join(os.path.join(osgAbsPath, 'MESHES'), meshType),
                                 backgroundsAbsPath, clean)    
    if 'p' in opts.mode:
        for (picType,clean) in (('CURR',False), ('HIST',True)):
            processSites('pic', os.path.join(os.path.join(dataAbsPath,'PICTURES'), picType), 
                                os.path.join(os.path.join(osgAbsPath, 'PICTURES'), picType), 
                                backgroundsAbsPath, clean)
    os.system('touch ' + os.path.join(osgAbsPath, 'LAST_MOD'))

def processPCBackgrounds(backgroundsAbsPath, osgBackgroundsAbsPath):
    t0 = time.time()
    cursor = connection.cursor()
    logging.info('Processing PC backgrounds in ' + backgroundsAbsPath)
    backgrounds = os.listdir(backgroundsAbsPath)
    for background in backgrounds:
        backgroundAbsPath = os.path.join(backgroundsAbsPath, background)
        osgBackgroundAbsPath = os.path.join(osgBackgroundsAbsPath, background)
        extension = checkExtension(backgroundAbsPath)
        if extension != None:
            checkedTime = utils.getCurrentTime()
            modTime = utils.getCurrentTime(utils.getLastModification(backgroundAbsPath))
            utils.dbExecute(cursor, 'SELECT static_object_id, last_mod FROM backgrounds_pc WHERE pc_folder = %s', [backgroundAbsPath,])
            row = cursor.fetchone()
            if row == None: #This folder has been added recently                
                (mainOSGB, _, offsets) = createOSG(os.path.join(backgroundAbsPath, '*' + extension), osgBackgroundAbsPath, 'bg')
                if mainOSGB != None:
                    utils.dbExecute(cursor, 'INSERT INTO static_objects (static_object_id, osg_path) VALUES (DEFAULT,%s) RETURNING static_object_id', [mainOSGB,])
                    staticObjectId = cursor.fetchone()[0]
                    utils.dbExecute(cursor, 'INSERT INTO backgrounds_pc (background_pc_id, static_object_id, pc_folder, offset_x, offset_y, offset_z, last_mod) VALUES (DEFAULT, %s,%s,%s,%s,%s,%s)', [staticObjectId, backgroundAbsPath, offsets[0], offsets[1], offsets[2], modTime])
            else:
                (staticObjectId, timeStamp) = row
                if modTime > timeStamp:
                    # Data has changed, we re-create the OSG data
                    (mainOSGB, _, offsets) = createOSG(os.path.join(backgroundAbsPath, '*' + extension), osgBackgroundAbsPath, 'bg')
                    if mainOSGB != None:
                        utils.dbExecute(cursor, 'UPDATE backgrounds_pc SET (offset_x, offset_y, offset_z, last_mod) = (%s,%s,%s, %s) WHERE static_object_id = %s', [offsets[0], offsets[1], offsets[2], modTime, staticObjectId])           
                    else:
                        utils.dbExecute(cursor, 'DELETE FROM static_objects WHERE static_object_id = %s', [staticObjectId,])
                        utils.dbExecute(cursor, 'DELETE FROM backgrounds_pc WHERE static_object_id = %s', [staticObjectId,])
            
            utils.dbExecute(cursor, 'UPDATE backgrounds_pc SET last_check=%s WHERE pc_folder = %s', [checkedTime, backgroundAbsPath,])
    
    # Clean removed folders
    utils.dbExecute(cursor, 'DELETE FROM backgrounds_pc WHERE last_check < %s RETURNING static_object_id', [initialTime,])
    rows = cursor.fetchall()
    for (staticObjectId,) in rows:
        utils.dbExecute(cursor, 'DELETE FROM static_objects WHERE static_object_id = %s RETURNING osg_path', [staticObjectId,])
        osgPath = cursor.fetchone()[0]
        shutil.rmtree(os.path.dirname(osgPath))
      
    logging.info('PC backgrounds processing finished in %.2f' % (time.time() - t0))
    cursor.close()


def processSites(inType, sitesAbsPath, osgSitesAbsPath, backgroundsAbsPath = None, cleanDB = False):
    t0 = time.time()
    if inType == 'pc':
        (tableName, idCol, pathCol) = ('sites_pc', 'site_pc_id', 'pc_path')
    elif inType == 'mesh':
        (tableName, idCol, pathCol) = ('sites_meshes', 'site_mesh_id', 'obj_path')
    elif inType == 'pic':
        (tableName, idCol, pathCol) = ('sites_pictures', 'site_picture_id', 'pic_path')
    else:
        raise Exception('Unknown type ' + inType)

    cursor = connection.cursor()
    logging.info('Processing sites ' + inType + ' in ' + sitesAbsPath)
    sites = os.listdir(sitesAbsPath)
    for site in sites:
        siteAbsPath = os.path.join(sitesAbsPath, site)
        osgSiteAbsPath = os.path.join(osgSitesAbsPath, site)
        siteId = checkSiteId(siteAbsPath)
        if siteId != None:
            for f in os.listdir(siteAbsPath):
                siteElementAbsPath = os.path.join(siteAbsPath, f)
                logging.debug('Processing ' + siteElementAbsPath)
                processElement = True
                color8Bit = None
                (aligned, alignedBackgroundId, abOffsetX, abOffsetY, abOffsetZ) = (None,None,None,None,None)
                if inType == 'pc':
                    extension = siteElementAbsPath.split('.')[-1]
                    osgElementAbsPath = os.path.join(osgSiteAbsPath, f).replace('.' + extension,'')
                    color8Bit = (siteElementAbsPath.lower().count('8bitcolor') > 0)
                    (aligned, alignedBackgroundId, abOffsetX, abOffsetY, abOffsetZ) = getAlignmentInfo(cursor, siteElementAbsPath, backgroundsAbsPath)
                    if extension not in PC_EXTENSIONS:
                        logging.error('Ignoring file ' + siteElementAbsPath + ': not a valid extension (' + ','.join(PC_EXTENSIONS) + ')')
                        processElement = False
                elif inType == 'mesh':
                    objFiles = glob.glob(os.path.join(siteElementAbsPath, '*.obj'))
                    osgElementAbsPath = os.path.join(osgSiteAbsPath, f)
                    (aligned, alignedBackgroundId, abOffsetX, abOffsetY, abOffsetZ) = getAlignmentInfo(cursor, siteElementAbsPath, backgroundsAbsPath)
                    if len(objFiles) > 1:
                        logging.error('Ignoring mesh folder ' + siteElementAbsPath + ': multiple OBJ files found')
                        processElement = False
                    elif len(objFiles) == 1:
                        siteElementAbsPath = objFiles[0]
                elif inType == 'pic':
                    extension = siteElementAbsPath.split('.')[-1]
                    osgElementAbsPath = os.path.join(osgSiteAbsPath, f).replace('.' + extension,'')
                    
                if processElement:
                    checkedTime = utils.getCurrentTime()
                    modTime = utils.getCurrentTime(utils.getLastModification(siteElementAbsPath))
                    utils.dbExecute(cursor, 'SELECT active_object_site_id, last_mod FROM ' + tableName + ' WHERE ' + pathCol + ' = %s', [siteElementAbsPath,])
                    row = cursor.fetchone()
                    if row == None: # This element has been added recently
                        (mainOSGB, xmlPath, offsets) = createOSG(siteElementAbsPath, osgElementAbsPath, inType, abOffsetX, abOffsetY, abOffsetZ, color8Bit)
                        if xmlPath != None:
                            if abOffsetX != None and offsets[0] != 0:
                                (x,y,z) = (offsets[0], offsets[1], offsets[2])
                            else:
                                (x,y) = utils.getPositionFromFootprint(cursor, siteId, backgroundsAbsPath)
                                z = utils.DEFAULT_Z
                
                            utils.dbExecute(cursor, 'INSERT INTO active_objects_sites (active_object_site_id, site_id, osg_path, xml_path, x,y,z,cast_shadow) VALUES (DEFAULT,%s,%s,%s,%s,%s,%s,%s) RETURNING active_object_site_id', [siteId, mainOSGB, xmlPath, x, y, z, False])
                            activeObjectId = cursor.fetchone()[0]
                            colNames = [idCol, 'active_object_site_id', pathCol, 'last_mod']
                            colPatts = ['DEFAULT','%s','%s','%s']
                            colValues = [activeObjectId, siteElementAbsPath, modTime]
                            if aligned != None:
                                colNames.append('aligned')
                                colPatts.append('%s')
                                colValues.append(aligned)
                            if color8Bit != None:
                                colNames.append('color_8_bit')
                                colPatts.append('%s')
                                colValues.append(color8Bit)                        
                            utils.dbExecute(cursor, 'INSERT INTO ' + tableName + ' (' + ','.join(colNames) + ') VALUES (' + ','.join(colPatts) + ') RETURNING ' + idCol, colValues)
                            elementId = cursor.fetchone()[0]
                            if aligned:
                                utils.dbExecute(cursor, 'INSERT INTO aligned_' + tableName + ' (' + idCol + ', background_pc_id) VALUES (%s,%s)', [elementId, alignedBackgroundId])
                            updateXMLDescription(xmlPath, siteId, inType, activeObjectId, mainOSGB)
                    else:
                        (activeObjectId, timeStamp) = row
                        if modTime > timeStamp:
                            # Data has changed, we re-create the OSG data
                            (mainOSGB, xmlPath, offsets) = createOSG(siteElementAbsPath, osgElementAbsPath, inType, abOffsetX, abOffsetY, abOffsetZ, color8Bit)
                            updateXMLDescription(xmlPath, siteId, inType, activeObjectId, mainOSGB)
                            if xmlPath != None:
                                utils.dbExecute(cursor, 'UPDATE ' + tableName + ' SET last_mod = %s WHERE active_object_site_id = %s', [modTime, activeObjectId])
                                #utils.dbExecute(cursor, 'UPDATE active_objects SET (x,y,z) = (%s,%s,%s) WHERE active_object_id = %s', [offsets[0], offsets[1], offsets[2], activeObjectId])                
                            else:
                                utils.dbExecute(cursor, 'DELETE FROM active_objects_sites WHERE active_object_site_id = %s', [activeObjectId,])
                                utils.dbExecute(cursor, 'DELETE FROM ' + tableName + ' WHERE active_object_site_id = %s', [activeObjectId,])
                                # Remove possible row in aligned_sites_pc (Done by the ON DELETE CASCADE in Foreign key)
                    utils.dbExecute(cursor, 'UPDATE ' + tableName + ' SET last_check = %s WHERE ' + pathCol + ' = %s', [checkedTime, siteElementAbsPath,])    
    if cleanDB:
        #Clean removed folders
        utils.dbExecute(cursor, 'DELETE FROM ' + tableName + ' WHERE last_check < %s RETURNING active_object_site_id', [initialTime,])
        rows = cursor.fetchall()
        for (activeObjectId,) in rows:
            utils.dbExecute(cursor, 'DELETE FROM active_objects_sites WHERE active_object_site_id = %s', [activeObjectId,])
    #Clean old OSG folders that are not linked in the DBs
    if os.path.isdir(osgSitesAbsPath):
        osites = os.listdir(osgSitesAbsPath )
        for osite in osites:
            osgSiteAbsPath = os.path.join(osgSitesAbsPath, osite)
            for f in os.listdir(osgSiteAbsPath):
                osgSiteElementAbsPath = os.path.join(osgSiteAbsPath, f)
                osgFiles = sorted(glob.glob(os.path.join(osgSiteElementAbsPath,'*' + getOSGFileFormat(inType))))
                if len(osgFiles) == 0:
                    logging.info('Folder ' + osgSiteElementAbsPath + ' does not contain OSG data. Deleting it...')
                    shutil.rmtree(osgSiteElementAbsPath)
                else:
                    osgFile = osgFiles[0]
                    utils.dbExecute(cursor, 'SELECT active_object_site_id FROM active_objects_sites WHERE osg_path = %s', [osgFile,])
                    row = cursor.fetchone()
                    if row == None:
                        logging.info('Folder ' + osgSiteElementAbsPath + ' contains unlinked OSG data. Deleting it...')
                        shutil.rmtree(osgSiteElementAbsPath)
    logging.info('Sites ' + inType + ' in ' + sitesAbsPath + ' processing finished in %.2f' % (time.time() - t0))
    cursor.close()

def getAlignmentInfo(cursor, absPath, backgroundsAbsPath):
    (aligned, alignedBackgroundId, abOffsetX,abOffsetY,abOffsetZ) = ((absPath.lower().count('_aligned_') > 0), None, None, None, None)
    if aligned:
        background =  os.path.basename(absPath)[os.path.basename(absPath).lower().index('_aligned_')+len('_aligned_'):].split('.')[0]
        backgroundAbsPath = os.path.join(backgroundsAbsPath, background)
        utils.dbExecute(cursor, 'SELECT background_pc_id, offset_x, offset_y, offset_z FROM backgrounds_pc WHERE pc_folder = %s', [backgroundAbsPath,])
        row = cursor.fetchone()
        if row == None:
            logging.warn('Ignoring alignment information: unknown background ' + backgroundAbsPath)
            aligned = False
        else:
            (alignedBackgroundId, abOffsetX,abOffsetY,abOffsetZ) = row
    return (aligned, alignedBackgroundId, abOffsetX,abOffsetY,abOffsetZ)

def getOSGFileFormat(inType):
#    if inType == 'pic':
#        return 'osgt'
    return 'osgb'

def updateXMLDescription(xmlPath, siteId, inType, activeObjectId, fileName = None):
    tempFile = xmlPath + '_TEMP'
    ofile = open(tempFile,'w')
    lines = open(xmlPath,'r').readlines()
    for line in lines:
        if line.count('<description>'):
            ofile.write('    <description>' + utils.getOSGDescrition(siteId, inType, activeObjectId, os.path.basename(os.path.dirname(fileName))) + '</description>\n')
        else:
            ofile.write(line)
    os.system('rm ' + xmlPath)
    os.system('mv ' + tempFile + ' ' + xmlPath)

def createOSG(inFile, outFolder, inType, abOffsetX = None, abOffsetY = None, abOffsetZ = None, color8Bit = False):
    (mainOsgb, xmlPath, offsets) = (None, None, (0,0,0))
    
    if os.path.exists(outFolder):
        os.system('rm -rf ' + outFolder) 
    os.makedirs(outFolder)
    
    os.chdir(os.path.dirname(inFile))
    outputPrefix = 'data'
    aligned = (abOffsetX != None)
    
    ofile = getOSGFileFormat(inType)
    if inType == 'pc':
        tmode = '--mode lodPoints --reposition'
#        outputPrefix = 'data' + os.path.basename(inFile)
    elif inType == 'mesh':
        tmode = '--mode polyMesh --convert --reposition'
    elif inType == 'bg':
        tmode = '--mode quadtree --reposition'
    elif inType == 'pic':
        tmode = '--mode picturePlane'
    
        
    command = CONVERTER_COMMAND + ' ' + tmode + ' --outputPrefix ' + outputPrefix + ' --files ' + os.path.basename(inFile)
    if color8Bit:
        command += ' --8bitColor '
    if aligned:
        command +=  ' --translate ' + str(abOffsetX) + ' ' + str(abOffsetY) + ' ' + str(abOffsetZ)
    
    logFile = os.path.join(outFolder,outputPrefix + '.log')
    command += ' &> ' + logFile

    logging.info(command)
    #os.system(command)
    subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell = True).communicate()
   
#     if inType == 'mesh':
#         rmcommand = 'rm -rf ' + inFile.replace('.obj', '2.obj')
#         logging.info(rmcommand)
#         os.system(rmcommand)
 
    mvcommand = 'mv ' + outputPrefix + '* ' + outFolder
    logging.info(mvcommand)
    os.system(mvcommand)
    outputPrefix += os.path.basename(inFile)

    ofiles = sorted(glob.glob(os.path.join(outFolder,'*' + ofile)))
    if len(ofiles) == 0:
        logging.error('none OSG file was generated (found in ' + outFolder + '). Check log: ' + logFile)
        mainOsgb = None
    else:
        mainOsgb = ofiles[0]
        if inType != 'bg':
            xmlfiles = glob.glob(os.path.join(outFolder,'*xml'))
            if len(xmlfiles) == 0:
                logging.error('none XML file was generated (found in ' + outFolder + '). Check log: ' + logFile)
                xmlPath = None
            else:
                xmlPath = xmlfiles[0]
                if len(xmlfiles) > 1:
                    logging.error('multiple XMLs file were generated (found in ' + outFolder + '). Using ' + xmlPath)
        txtfiles =  glob.glob(os.path.join(outFolder,'*offset.txt'))
        if len(txtfiles):
            txtFile = txtfiles[0]
            offsets = open(txtFile,'r').read().split('\n')[0].split(':')[1].split()
            for i in range(len(offsets)):
                offsets[i] = float(offsets[i]) 
        elif aligned:
            logging.warn('No offset file was found and it was expected!')
            
    return (mainOsgb, xmlPath, offsets)

def checkExtension(absPath, allowMultiple = False):
    """ Return the extension of the PC file/files in the provided folder. 
    If the path is empty or there aren't valid PC_EXTENSIONS it returns None.
    If allowMultiple is False it also returns None if there are multiple PC_EXTENSIONS.
    If allowMultiple is True it return the extension of the first PC file"""
    numFiles = len(os.listdir(absPath))
    if numFiles:
        extensions = []
        for extension in PC_EXTENSIONS:
            if len(glob.glob(os.path.join(absPath,'*'+extension))):
                extensions.append(extension)
        if len(extensions) > 1:
            if allowMultiple:
                return extensions[0]
            else:
                logging.warn('Ignoring folder ' + absPath + ': multiple valid PC_EXTENSIONS (' + ','.join(PC_EXTENSIONS) + ')')
        elif len(extensions) == 0:
            logging.warn('Ignoring folder ' + absPath + ': no data with valid PC_EXTENSIONS (' + ','.join(PC_EXTENSIONS) + ')')
        else: #len(hasPC_EXTENSIONS) == 1:
            return extensions[0]

def checkSiteId(absPath):
    try:
        siteId = int(os.path.basename(absPath))
    except:
        logging.warn('ignoring folder ' + absPath + '. Folder name must be a siteID')
        siteId = None
    return siteId

if __name__ == "__main__":
    usage = 'Usage: %prog [options]'
    description = "Creates the OSG data for all the new data contained in the DATA folder and updates DB with information (it checks time stamps)"
    op = optparse.OptionParser(usage=usage, description=description)
    op.add_option('-i','--data',default=utils.DEFAULT_RAW_DATA_FOLDER,help='RAW data folder [default ' + utils.DEFAULT_RAW_DATA_FOLDER + ']',type='string')
    op.add_option('-o','--osg',default=utils.DEFAULT_OSG_DATA_DIR,help='OSG data directory [default ' + utils.DEFAULT_OSG_DATA_DIR + ']',type='string')
    op.add_option('-m','--mode',default=DEFAULT_MODE,help='Running mode. What is to be updated? b for background, s for sites, m for meshes, p for pictures [default all is checked, i.e. ' + DEFAULT_MODE + ']',type='string')
    op.add_option('-d','--dbname',default=utils.DEFAULT_DB,help='Postgres DB name where to store the geometries [default ' + utils.DEFAULT_DB + ']',type='string')
    op.add_option('-u','--dbuser',default=utils.USERNAME,help='DB user [default ' + utils.USERNAME + ']',type='string')
    op.add_option('-p','--dbpass',default='',help='DB pass',type='string')
    op.add_option('-t','--dbhost',default='',help='DB host',type='string')
    op.add_option('-r','--dbport',default='',help='DB port',type='string')
    op.add_option('-l','--log',help='Logging level (choose from ' + ','.join(LOG_LEVELS) + ' ; default ' + DEFAULT_LOG_LEVEL + ')',type='choice', choices=LOG_LEVELS, default=DEFAULT_LOG_LEVEL)
    (opts, args) = op.parse_args()
    main(opts)
